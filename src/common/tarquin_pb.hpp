// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tarquin.proto

#ifndef PROTOBUF_tarquin_2eproto__INCLUDED
#define PROTOBUF_tarquin_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2003000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace sln {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_tarquin_2eproto();
void protobuf_AssignDesc_tarquin_2eproto();
void protobuf_ShutdownFile_tarquin_2eproto();

class results;
class fid;
class coord;
class comp_point;
class comp_vec;
class comp_mat;
class vec;
class signal;
class basis;
class options;
class constraints;

enum options_fidformat {
  options_fidformat_DANGER = 0,
  options_fidformat_SIEMENS = 1,
  options_fidformat_PHILIPS = 2,
  options_fidformat_GE = 3,
  options_fidformat_RDA = 4,
  options_fidformat_LCM = 5,
  options_fidformat_SHF = 6,
  options_fidformat_VARIAN = 7,
  options_fidformat_BRUKER = 8,
  options_fidformat_DCM = 9,
  options_fidformat_PHILIPS_DCM = 10,
  options_fidformat_JMRUI_TXT = 11,
  options_fidformat_NOTSET = 12
};
bool options_fidformat_IsValid(int value);
const options_fidformat options_fidformat_fidformat_MIN = options_fidformat_DANGER;
const options_fidformat options_fidformat_fidformat_MAX = options_fidformat_NOTSET;
const int options_fidformat_fidformat_ARRAYSIZE = options_fidformat_fidformat_MAX + 1;

const ::google::protobuf::EnumDescriptor* options_fidformat_descriptor();
inline const ::std::string& options_fidformat_Name(options_fidformat value) {
  return ::google::protobuf::internal::NameOfEnum(
    options_fidformat_descriptor(), value);
}
inline bool options_fidformat_Parse(
    const ::std::string& name, options_fidformat* value) {
  return ::google::protobuf::internal::ParseNamedEnum<options_fidformat>(
    options_fidformat_descriptor(), name, value);
}
// ===================================================================

class results : public ::google::protobuf::Message {
 public:
  results();
  virtual ~results();
  
  results(const results& from);
  
  inline results& operator=(const results& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const results& default_instance();
  
  void Swap(results* other);
  
  // implements Message ----------------------------------------------
  
  results* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const results& from);
  void MergeFrom(const results& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .sln.fid fidraw = 1;
  inline bool has_fidraw() const;
  inline void clear_fidraw();
  static const int kFidrawFieldNumber = 1;
  inline const ::sln::fid& fidraw() const;
  inline ::sln::fid* mutable_fidraw();
  
  // optional .sln.fid fidproc = 2;
  inline bool has_fidproc() const;
  inline void clear_fidproc();
  static const int kFidprocFieldNumber = 2;
  inline const ::sln::fid& fidproc() const;
  inline ::sln::fid* mutable_fidproc();
  
  // optional .sln.fid fidwater = 3;
  inline bool has_fidwater() const;
  inline void clear_fidwater();
  static const int kFidwaterFieldNumber = 3;
  inline const ::sln::fid& fidwater() const;
  inline ::sln::fid* mutable_fidwater();
  
  // optional .sln.basis basis = 4;
  inline bool has_basis() const;
  inline void clear_basis();
  static const int kBasisFieldNumber = 4;
  inline const ::sln::basis& basis() const;
  inline ::sln::basis* mutable_basis();
  
  // optional .sln.options options = 5;
  inline bool has_options() const;
  inline void clear_options();
  static const int kOptionsFieldNumber = 5;
  inline const ::sln::options& options() const;
  inline ::sln::options* mutable_options();
  
  // repeated .sln.comp_vec yhat = 6;
  inline int yhat_size() const;
  inline void clear_yhat();
  static const int kYhatFieldNumber = 6;
  inline const ::sln::comp_vec& yhat(int index) const;
  inline ::sln::comp_vec* mutable_yhat(int index);
  inline ::sln::comp_vec* add_yhat();
  inline const ::google::protobuf::RepeatedPtrField< ::sln::comp_vec >&
      yhat() const;
  inline ::google::protobuf::RepeatedPtrField< ::sln::comp_vec >*
      mutable_yhat();
  
  // repeated .sln.vec amplitudes = 7;
  inline int amplitudes_size() const;
  inline void clear_amplitudes();
  static const int kAmplitudesFieldNumber = 7;
  inline const ::sln::vec& amplitudes(int index) const;
  inline ::sln::vec* mutable_amplitudes(int index);
  inline ::sln::vec* add_amplitudes();
  inline const ::google::protobuf::RepeatedPtrField< ::sln::vec >&
      amplitudes() const;
  inline ::google::protobuf::RepeatedPtrField< ::sln::vec >*
      mutable_amplitudes();
  
  // repeated .sln.comp_mat matgroups = 8;
  inline int matgroups_size() const;
  inline void clear_matgroups();
  static const int kMatgroupsFieldNumber = 8;
  inline const ::sln::comp_mat& matgroups(int index) const;
  inline ::sln::comp_mat* mutable_matgroups(int index);
  inline ::sln::comp_mat* add_matgroups();
  inline const ::google::protobuf::RepeatedPtrField< ::sln::comp_mat >&
      matgroups() const;
  inline ::google::protobuf::RepeatedPtrField< ::sln::comp_mat >*
      mutable_matgroups();
  
  // repeated .sln.comp_mat matbasis = 9;
  inline int matbasis_size() const;
  inline void clear_matbasis();
  static const int kMatbasisFieldNumber = 9;
  inline const ::sln::comp_mat& matbasis(int index) const;
  inline ::sln::comp_mat* mutable_matbasis(int index);
  inline ::sln::comp_mat* add_matbasis();
  inline const ::google::protobuf::RepeatedPtrField< ::sln::comp_mat >&
      matbasis() const;
  inline ::google::protobuf::RepeatedPtrField< ::sln::comp_mat >*
      mutable_matbasis();
  
  // repeated double lm_opts = 10;
  inline int lm_opts_size() const;
  inline void clear_lm_opts();
  static const int kLmOptsFieldNumber = 10;
  inline double lm_opts(int index) const;
  inline void set_lm_opts(int index, double value);
  inline void add_lm_opts(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      lm_opts() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_lm_opts();
  
  // repeated .sln.vec lm_info = 11;
  inline int lm_info_size() const;
  inline void clear_lm_info();
  static const int kLmInfoFieldNumber = 11;
  inline const ::sln::vec& lm_info(int index) const;
  inline ::sln::vec* mutable_lm_info(int index);
  inline ::sln::vec* add_lm_info();
  inline const ::google::protobuf::RepeatedPtrField< ::sln::vec >&
      lm_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::sln::vec >*
      mutable_lm_info();
  
  // repeated double norm_val = 12;
  inline int norm_val_size() const;
  inline void clear_norm_val();
  static const int kNormValFieldNumber = 12;
  inline double norm_val(int index) const;
  inline void set_norm_val(int index, double value);
  inline void add_norm_val(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      norm_val() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_norm_val();
  
  // repeated .sln.vec crlbs = 13;
  inline int crlbs_size() const;
  inline void clear_crlbs();
  static const int kCrlbsFieldNumber = 13;
  inline const ::sln::vec& crlbs(int index) const;
  inline ::sln::vec* mutable_crlbs(int index);
  inline ::sln::vec* add_crlbs();
  inline const ::google::protobuf::RepeatedPtrField< ::sln::vec >&
      crlbs() const;
  inline ::google::protobuf::RepeatedPtrField< ::sln::vec >*
      mutable_crlbs();
  
  // repeated double q = 14;
  inline int q_size() const;
  inline void clear_q();
  static const int kQFieldNumber = 14;
  inline double q(int index) const;
  inline void set_q(int index, double value);
  inline void add_q(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      q() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_q();
  
  // repeated .sln.vec amp_norm = 15;
  inline int amp_norm_size() const;
  inline void clear_amp_norm();
  static const int kAmpNormFieldNumber = 15;
  inline const ::sln::vec& amp_norm(int index) const;
  inline ::sln::vec* mutable_amp_norm(int index);
  inline ::sln::vec* add_amp_norm();
  inline const ::google::protobuf::RepeatedPtrField< ::sln::vec >&
      amp_norm() const;
  inline ::google::protobuf::RepeatedPtrField< ::sln::vec >*
      mutable_amp_norm();
  
  // repeated .sln.vec crlbs_norm = 16;
  inline int crlbs_norm_size() const;
  inline void clear_crlbs_norm();
  static const int kCrlbsNormFieldNumber = 16;
  inline const ::sln::vec& crlbs_norm(int index) const;
  inline ::sln::vec* mutable_crlbs_norm(int index);
  inline ::sln::vec* add_crlbs_norm();
  inline const ::google::protobuf::RepeatedPtrField< ::sln::vec >&
      crlbs_norm() const;
  inline ::google::protobuf::RepeatedPtrField< ::sln::vec >*
      mutable_crlbs_norm();
  
  // @@protoc_insertion_point(class_scope:sln.results)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::sln::fid* fidraw_;
  ::sln::fid* fidproc_;
  ::sln::fid* fidwater_;
  ::sln::basis* basis_;
  ::sln::options* options_;
  ::google::protobuf::RepeatedPtrField< ::sln::comp_vec > yhat_;
  ::google::protobuf::RepeatedPtrField< ::sln::vec > amplitudes_;
  ::google::protobuf::RepeatedPtrField< ::sln::comp_mat > matgroups_;
  ::google::protobuf::RepeatedPtrField< ::sln::comp_mat > matbasis_;
  ::google::protobuf::RepeatedField< double > lm_opts_;
  ::google::protobuf::RepeatedPtrField< ::sln::vec > lm_info_;
  ::google::protobuf::RepeatedField< double > norm_val_;
  ::google::protobuf::RepeatedPtrField< ::sln::vec > crlbs_;
  ::google::protobuf::RepeatedField< double > q_;
  ::google::protobuf::RepeatedPtrField< ::sln::vec > amp_norm_;
  ::google::protobuf::RepeatedPtrField< ::sln::vec > crlbs_norm_;
  friend void  protobuf_AddDesc_tarquin_2eproto();
  friend void protobuf_AssignDesc_tarquin_2eproto();
  friend void protobuf_ShutdownFile_tarquin_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(16 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static results* default_instance_;
};
// -------------------------------------------------------------------

class fid : public ::google::protobuf::Message {
 public:
  fid();
  virtual ~fid();
  
  fid(const fid& from);
  
  inline fid& operator=(const fid& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const fid& default_instance();
  
  void Swap(fid* other);
  
  // implements Message ----------------------------------------------
  
  fid* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const fid& from);
  void MergeFrom(const fid& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string strfilename = 1;
  inline bool has_strfilename() const;
  inline void clear_strfilename();
  static const int kStrfilenameFieldNumber = 1;
  inline const ::std::string& strfilename() const;
  inline void set_strfilename(const ::std::string& value);
  inline void set_strfilename(const char* value);
  inline void set_strfilename(const char* value, size_t size);
  inline ::std::string* mutable_strfilename();
  
  // optional double fs = 2;
  inline bool has_fs() const;
  inline void clear_fs();
  static const int kFsFieldNumber = 2;
  inline double fs() const;
  inline void set_fs(double value);
  
  // optional bool bsamplingfrequencyknown = 3;
  inline bool has_bsamplingfrequencyknown() const;
  inline void clear_bsamplingfrequencyknown();
  static const int kBsamplingfrequencyknownFieldNumber = 3;
  inline bool bsamplingfrequencyknown() const;
  inline void set_bsamplingfrequencyknown(bool value);
  
  // optional double ft = 4;
  inline bool has_ft() const;
  inline void clear_ft();
  static const int kFtFieldNumber = 4;
  inline double ft() const;
  inline void set_ft(double value);
  
  // optional bool btransmitterfrequencyknown = 5;
  inline bool has_btransmitterfrequencyknown() const;
  inline void clear_btransmitterfrequencyknown();
  static const int kBtransmitterfrequencyknownFieldNumber = 5;
  inline bool btransmitterfrequencyknown() const;
  inline void set_btransmitterfrequencyknown(bool value);
  
  // optional string strsequence = 6;
  inline bool has_strsequence() const;
  inline void clear_strsequence();
  static const int kStrsequenceFieldNumber = 6;
  inline const ::std::string& strsequence() const;
  inline void set_strsequence(const ::std::string& value);
  inline void set_strsequence(const char* value);
  inline void set_strsequence(const char* value, size_t size);
  inline ::std::string* mutable_strsequence();
  
  // optional bool pulsesequenceknown = 7;
  inline bool has_pulsesequenceknown() const;
  inline void clear_pulsesequenceknown();
  static const int kPulsesequenceknownFieldNumber = 7;
  inline bool pulsesequenceknown() const;
  inline void set_pulsesequenceknown(bool value);
  
  // optional int32 naverages = 8;
  inline bool has_naverages() const;
  inline void clear_naverages();
  static const int kNaveragesFieldNumber = 8;
  inline ::google::protobuf::int32 naverages() const;
  inline void set_naverages(::google::protobuf::int32 value);
  
  // optional bool baveragesknown = 9;
  inline bool has_baveragesknown() const;
  inline void clear_baveragesknown();
  static const int kBaveragesknownFieldNumber = 9;
  inline bool baveragesknown() const;
  inline void set_baveragesknown(bool value);
  
  // repeated double phi0 = 10;
  inline int phi0_size() const;
  inline void clear_phi0();
  static const int kPhi0FieldNumber = 10;
  inline double phi0(int index) const;
  inline void set_phi0(int index, double value);
  inline void add_phi0(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      phi0() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_phi0();
  
  // repeated bool bzeroorderphaseknown = 11;
  inline int bzeroorderphaseknown_size() const;
  inline void clear_bzeroorderphaseknown();
  static const int kBzeroorderphaseknownFieldNumber = 11;
  inline bool bzeroorderphaseknown(int index) const;
  inline void set_bzeroorderphaseknown(int index, bool value);
  inline void add_bzeroorderphaseknown(bool value);
  inline const ::google::protobuf::RepeatedField< bool >&
      bzeroorderphaseknown() const;
  inline ::google::protobuf::RepeatedField< bool >*
      mutable_bzeroorderphaseknown();
  
  // repeated double phi1 = 12;
  inline int phi1_size() const;
  inline void clear_phi1();
  static const int kPhi1FieldNumber = 12;
  inline double phi1(int index) const;
  inline void set_phi1(int index, double value);
  inline void add_phi1(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      phi1() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_phi1();
  
  // repeated bool bfirstorderphaseknown = 13;
  inline int bfirstorderphaseknown_size() const;
  inline void clear_bfirstorderphaseknown();
  static const int kBfirstorderphaseknownFieldNumber = 13;
  inline bool bfirstorderphaseknown(int index) const;
  inline void set_bfirstorderphaseknown(int index, bool value);
  inline void add_bfirstorderphaseknown(bool value);
  inline const ::google::protobuf::RepeatedField< bool >&
      bfirstorderphaseknown() const;
  inline ::google::protobuf::RepeatedField< bool >*
      mutable_bfirstorderphaseknown();
  
  // repeated double ref = 14;
  inline int ref_size() const;
  inline void clear_ref();
  static const int kRefFieldNumber = 14;
  inline double ref(int index) const;
  inline void set_ref(int index, double value);
  inline void add_ref(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      ref() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_ref();
  
  // repeated bool breferenceknown = 15;
  inline int breferenceknown_size() const;
  inline void clear_breferenceknown();
  static const int kBreferenceknownFieldNumber = 15;
  inline bool breferenceknown(int index) const;
  inline void set_breferenceknown(int index, bool value);
  inline void add_breferenceknown(bool value);
  inline const ::google::protobuf::RepeatedField< bool >&
      breferenceknown() const;
  inline ::google::protobuf::RepeatedField< bool >*
      mutable_breferenceknown();
  
  // optional double tau = 16;
  inline bool has_tau() const;
  inline void clear_tau();
  static const int kTauFieldNumber = 16;
  inline double tau() const;
  inline void set_tau(double value);
  
  // optional bool bechoknown = 17;
  inline bool has_bechoknown() const;
  inline void clear_bechoknown();
  static const int kBechoknownFieldNumber = 17;
  inline bool bechoknown() const;
  inline void set_bechoknown(bool value);
  
  // repeated double snr = 18;
  inline int snr_size() const;
  inline void clear_snr();
  static const int kSnrFieldNumber = 18;
  inline double snr(int index) const;
  inline void set_snr(int index, double value);
  inline void add_snr(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      snr() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_snr();
  
  // repeated bool bsnrknown = 19;
  inline int bsnrknown_size() const;
  inline void clear_bsnrknown();
  static const int kBsnrknownFieldNumber = 19;
  inline bool bsnrknown(int index) const;
  inline void set_bsnrknown(int index, bool value);
  inline void add_bsnrknown(bool value);
  inline const ::google::protobuf::RepeatedField< bool >&
      bsnrknown() const;
  inline ::google::protobuf::RepeatedField< bool >*
      mutable_bsnrknown();
  
  // optional int32 npoints = 20;
  inline bool has_npoints() const;
  inline void clear_npoints();
  static const int kNpointsFieldNumber = 20;
  inline ::google::protobuf::int32 npoints() const;
  inline void set_npoints(::google::protobuf::int32 value);
  
  // repeated .sln.comp_vec fids = 21;
  inline int fids_size() const;
  inline void clear_fids();
  static const int kFidsFieldNumber = 21;
  inline const ::sln::comp_vec& fids(int index) const;
  inline ::sln::comp_vec* mutable_fids(int index);
  inline ::sln::comp_vec* add_fids();
  inline const ::google::protobuf::RepeatedPtrField< ::sln::comp_vec >&
      fids() const;
  inline ::google::protobuf::RepeatedPtrField< ::sln::comp_vec >*
      mutable_fids();
  
  // optional double norm_val = 22;
  inline bool has_norm_val() const;
  inline void clear_norm_val();
  static const int kNormValFieldNumber = 22;
  inline double norm_val() const;
  inline void set_norm_val(double value);
  
  // optional int32 rows = 23;
  inline bool has_rows() const;
  inline void clear_rows();
  static const int kRowsFieldNumber = 23;
  inline ::google::protobuf::int32 rows() const;
  inline void set_rows(::google::protobuf::int32 value);
  
  // optional int32 cols = 24;
  inline bool has_cols() const;
  inline void clear_cols();
  static const int kColsFieldNumber = 24;
  inline ::google::protobuf::int32 cols() const;
  inline void set_cols(::google::protobuf::int32 value);
  
  // optional int32 slices = 25;
  inline bool has_slices() const;
  inline void clear_slices();
  static const int kSlicesFieldNumber = 25;
  inline ::google::protobuf::int32 slices() const;
  inline void set_slices(::google::protobuf::int32 value);
  
  // optional bool voxel_dim_known = 26;
  inline bool has_voxel_dim_known() const;
  inline void clear_voxel_dim_known();
  static const int kVoxelDimKnownFieldNumber = 26;
  inline bool voxel_dim_known() const;
  inline void set_voxel_dim_known(bool value);
  
  // repeated double voxel_dim = 27;
  inline int voxel_dim_size() const;
  inline void clear_voxel_dim();
  static const int kVoxelDimFieldNumber = 27;
  inline double voxel_dim(int index) const;
  inline void set_voxel_dim(int index, double value);
  inline void add_voxel_dim(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      voxel_dim() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_voxel_dim();
  
  // optional bool voi_dim_known = 28;
  inline bool has_voi_dim_known() const;
  inline void clear_voi_dim_known();
  static const int kVoiDimKnownFieldNumber = 28;
  inline bool voi_dim_known() const;
  inline void set_voi_dim_known(bool value);
  
  // repeated double voi_dim = 29;
  inline int voi_dim_size() const;
  inline void clear_voi_dim();
  static const int kVoiDimFieldNumber = 29;
  inline double voi_dim(int index) const;
  inline void set_voi_dim(int index, double value);
  inline void add_voi_dim(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      voi_dim() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_voi_dim();
  
  // optional bool pos_known = 30;
  inline bool has_pos_known() const;
  inline void clear_pos_known();
  static const int kPosKnownFieldNumber = 30;
  inline bool pos_known() const;
  inline void set_pos_known(bool value);
  
  // repeated double pos = 31;
  inline int pos_size() const;
  inline void clear_pos();
  static const int kPosFieldNumber = 31;
  inline double pos(int index) const;
  inline void set_pos(int index, double value);
  inline void add_pos(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      pos() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_pos();
  
  // optional bool row_dirn_known = 32;
  inline bool has_row_dirn_known() const;
  inline void clear_row_dirn_known();
  static const int kRowDirnKnownFieldNumber = 32;
  inline bool row_dirn_known() const;
  inline void set_row_dirn_known(bool value);
  
  // repeated double row_dirn = 33;
  inline int row_dirn_size() const;
  inline void clear_row_dirn();
  static const int kRowDirnFieldNumber = 33;
  inline double row_dirn(int index) const;
  inline void set_row_dirn(int index, double value);
  inline void add_row_dirn(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      row_dirn() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_row_dirn();
  
  // optional bool col_dirn_known = 34;
  inline bool has_col_dirn_known() const;
  inline void clear_col_dirn_known();
  static const int kColDirnKnownFieldNumber = 34;
  inline bool col_dirn_known() const;
  inline void set_col_dirn_known(bool value);
  
  // repeated double col_dirn = 35;
  inline int col_dirn_size() const;
  inline void clear_col_dirn();
  static const int kColDirnFieldNumber = 35;
  inline double col_dirn(int index) const;
  inline void set_col_dirn(int index, double value);
  inline void add_col_dirn(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      col_dirn() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_col_dirn();
  
  // @@protoc_insertion_point(class_scope:sln.fid)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* strfilename_;
  static const ::std::string _default_strfilename_;
  double fs_;
  bool bsamplingfrequencyknown_;
  double ft_;
  bool btransmitterfrequencyknown_;
  ::std::string* strsequence_;
  static const ::std::string _default_strsequence_;
  bool pulsesequenceknown_;
  ::google::protobuf::int32 naverages_;
  bool baveragesknown_;
  ::google::protobuf::RepeatedField< double > phi0_;
  ::google::protobuf::RepeatedField< bool > bzeroorderphaseknown_;
  ::google::protobuf::RepeatedField< double > phi1_;
  ::google::protobuf::RepeatedField< bool > bfirstorderphaseknown_;
  ::google::protobuf::RepeatedField< double > ref_;
  ::google::protobuf::RepeatedField< bool > breferenceknown_;
  double tau_;
  bool bechoknown_;
  ::google::protobuf::RepeatedField< double > snr_;
  ::google::protobuf::RepeatedField< bool > bsnrknown_;
  ::google::protobuf::int32 npoints_;
  ::google::protobuf::RepeatedPtrField< ::sln::comp_vec > fids_;
  double norm_val_;
  ::google::protobuf::int32 rows_;
  ::google::protobuf::int32 cols_;
  ::google::protobuf::int32 slices_;
  bool voxel_dim_known_;
  ::google::protobuf::RepeatedField< double > voxel_dim_;
  bool voi_dim_known_;
  ::google::protobuf::RepeatedField< double > voi_dim_;
  bool pos_known_;
  ::google::protobuf::RepeatedField< double > pos_;
  bool row_dirn_known_;
  ::google::protobuf::RepeatedField< double > row_dirn_;
  bool col_dirn_known_;
  ::google::protobuf::RepeatedField< double > col_dirn_;
  friend void  protobuf_AddDesc_tarquin_2eproto();
  friend void protobuf_AssignDesc_tarquin_2eproto();
  friend void protobuf_ShutdownFile_tarquin_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(35 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static fid* default_instance_;
};
// -------------------------------------------------------------------

class coord : public ::google::protobuf::Message {
 public:
  coord();
  virtual ~coord();
  
  coord(const coord& from);
  
  inline coord& operator=(const coord& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const coord& default_instance();
  
  void Swap(coord* other);
  
  // implements Message ----------------------------------------------
  
  coord* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const coord& from);
  void MergeFrom(const coord& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 row = 1;
  inline bool has_row() const;
  inline void clear_row();
  static const int kRowFieldNumber = 1;
  inline ::google::protobuf::int32 row() const;
  inline void set_row(::google::protobuf::int32 value);
  
  // optional int32 col = 2;
  inline bool has_col() const;
  inline void clear_col();
  static const int kColFieldNumber = 2;
  inline ::google::protobuf::int32 col() const;
  inline void set_col(::google::protobuf::int32 value);
  
  // optional int32 slice = 3;
  inline bool has_slice() const;
  inline void clear_slice();
  static const int kSliceFieldNumber = 3;
  inline ::google::protobuf::int32 slice() const;
  inline void set_slice(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:sln.coord)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 row_;
  ::google::protobuf::int32 col_;
  ::google::protobuf::int32 slice_;
  friend void  protobuf_AddDesc_tarquin_2eproto();
  friend void protobuf_AssignDesc_tarquin_2eproto();
  friend void protobuf_ShutdownFile_tarquin_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static coord* default_instance_;
};
// -------------------------------------------------------------------

class comp_point : public ::google::protobuf::Message {
 public:
  comp_point();
  virtual ~comp_point();
  
  comp_point(const comp_point& from);
  
  inline comp_point& operator=(const comp_point& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const comp_point& default_instance();
  
  void Swap(comp_point* other);
  
  // implements Message ----------------------------------------------
  
  comp_point* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const comp_point& from);
  void MergeFrom(const comp_point& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional double real = 1;
  inline bool has_real() const;
  inline void clear_real();
  static const int kRealFieldNumber = 1;
  inline double real() const;
  inline void set_real(double value);
  
  // optional double imag = 2;
  inline bool has_imag() const;
  inline void clear_imag();
  static const int kImagFieldNumber = 2;
  inline double imag() const;
  inline void set_imag(double value);
  
  // @@protoc_insertion_point(class_scope:sln.comp_point)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  double real_;
  double imag_;
  friend void  protobuf_AddDesc_tarquin_2eproto();
  friend void protobuf_AssignDesc_tarquin_2eproto();
  friend void protobuf_ShutdownFile_tarquin_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static comp_point* default_instance_;
};
// -------------------------------------------------------------------

class comp_vec : public ::google::protobuf::Message {
 public:
  comp_vec();
  virtual ~comp_vec();
  
  comp_vec(const comp_vec& from);
  
  inline comp_vec& operator=(const comp_vec& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const comp_vec& default_instance();
  
  void Swap(comp_vec* other);
  
  // implements Message ----------------------------------------------
  
  comp_vec* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const comp_vec& from);
  void MergeFrom(const comp_vec& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .sln.comp_point comp_point = 1;
  inline int comp_point_size() const;
  inline void clear_comp_point();
  static const int kCompPointFieldNumber = 1;
  inline const ::sln::comp_point& comp_point(int index) const;
  inline ::sln::comp_point* mutable_comp_point(int index);
  inline ::sln::comp_point* add_comp_point();
  inline const ::google::protobuf::RepeatedPtrField< ::sln::comp_point >&
      comp_point() const;
  inline ::google::protobuf::RepeatedPtrField< ::sln::comp_point >*
      mutable_comp_point();
  
  // @@protoc_insertion_point(class_scope:sln.comp_vec)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::sln::comp_point > comp_point_;
  friend void  protobuf_AddDesc_tarquin_2eproto();
  friend void protobuf_AssignDesc_tarquin_2eproto();
  friend void protobuf_ShutdownFile_tarquin_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static comp_vec* default_instance_;
};
// -------------------------------------------------------------------

class comp_mat : public ::google::protobuf::Message {
 public:
  comp_mat();
  virtual ~comp_mat();
  
  comp_mat(const comp_mat& from);
  
  inline comp_mat& operator=(const comp_mat& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const comp_mat& default_instance();
  
  void Swap(comp_mat* other);
  
  // implements Message ----------------------------------------------
  
  comp_mat* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const comp_mat& from);
  void MergeFrom(const comp_mat& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .sln.comp_vec comp_vec = 1;
  inline int comp_vec_size() const;
  inline void clear_comp_vec();
  static const int kCompVecFieldNumber = 1;
  inline const ::sln::comp_vec& comp_vec(int index) const;
  inline ::sln::comp_vec* mutable_comp_vec(int index);
  inline ::sln::comp_vec* add_comp_vec();
  inline const ::google::protobuf::RepeatedPtrField< ::sln::comp_vec >&
      comp_vec() const;
  inline ::google::protobuf::RepeatedPtrField< ::sln::comp_vec >*
      mutable_comp_vec();
  
  // @@protoc_insertion_point(class_scope:sln.comp_mat)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::sln::comp_vec > comp_vec_;
  friend void  protobuf_AddDesc_tarquin_2eproto();
  friend void protobuf_AssignDesc_tarquin_2eproto();
  friend void protobuf_ShutdownFile_tarquin_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static comp_mat* default_instance_;
};
// -------------------------------------------------------------------

class vec : public ::google::protobuf::Message {
 public:
  vec();
  virtual ~vec();
  
  vec(const vec& from);
  
  inline vec& operator=(const vec& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const vec& default_instance();
  
  void Swap(vec* other);
  
  // implements Message ----------------------------------------------
  
  vec* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const vec& from);
  void MergeFrom(const vec& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated double point = 1;
  inline int point_size() const;
  inline void clear_point();
  static const int kPointFieldNumber = 1;
  inline double point(int index) const;
  inline void set_point(int index, double value);
  inline void add_point(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      point() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_point();
  
  // @@protoc_insertion_point(class_scope:sln.vec)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedField< double > point_;
  friend void  protobuf_AddDesc_tarquin_2eproto();
  friend void protobuf_AssignDesc_tarquin_2eproto();
  friend void protobuf_ShutdownFile_tarquin_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static vec* default_instance_;
};
// -------------------------------------------------------------------

class signal : public ::google::protobuf::Message {
 public:
  signal();
  virtual ~signal();
  
  signal(const signal& from);
  
  inline signal& operator=(const signal& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const signal& default_instance();
  
  void Swap(signal* other);
  
  // implements Message ----------------------------------------------
  
  signal* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const signal& from);
  void MergeFrom(const signal& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .sln.fid fid_vec = 1;
  inline int fid_vec_size() const;
  inline void clear_fid_vec();
  static const int kFidVecFieldNumber = 1;
  inline const ::sln::fid& fid_vec(int index) const;
  inline ::sln::fid* mutable_fid_vec(int index);
  inline ::sln::fid* add_fid_vec();
  inline const ::google::protobuf::RepeatedPtrField< ::sln::fid >&
      fid_vec() const;
  inline ::google::protobuf::RepeatedPtrField< ::sln::fid >*
      mutable_fid_vec();
  
  // @@protoc_insertion_point(class_scope:sln.signal)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::sln::fid > fid_vec_;
  friend void  protobuf_AddDesc_tarquin_2eproto();
  friend void protobuf_AssignDesc_tarquin_2eproto();
  friend void protobuf_ShutdownFile_tarquin_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static signal* default_instance_;
};
// -------------------------------------------------------------------

class basis : public ::google::protobuf::Message {
 public:
  basis();
  virtual ~basis();
  
  basis(const basis& from);
  
  inline basis& operator=(const basis& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const basis& default_instance();
  
  void Swap(basis* other);
  
  // implements Message ----------------------------------------------
  
  basis* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const basis& from);
  void MergeFrom(const basis& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string strbasispath = 1;
  inline bool has_strbasispath() const;
  inline void clear_strbasispath();
  static const int kStrbasispathFieldNumber = 1;
  inline const ::std::string& strbasispath() const;
  inline void set_strbasispath(const ::std::string& value);
  inline void set_strbasispath(const char* value);
  inline void set_strbasispath(const char* value, size_t size);
  inline ::std::string* mutable_strbasispath();
  
  // repeated string vecsignalfiles = 2;
  inline int vecsignalfiles_size() const;
  inline void clear_vecsignalfiles();
  static const int kVecsignalfilesFieldNumber = 2;
  inline const ::std::string& vecsignalfiles(int index) const;
  inline ::std::string* mutable_vecsignalfiles(int index);
  inline void set_vecsignalfiles(int index, const ::std::string& value);
  inline void set_vecsignalfiles(int index, const char* value);
  inline void set_vecsignalfiles(int index, const char* value, size_t size);
  inline ::std::string* add_vecsignalfiles();
  inline void add_vecsignalfiles(const ::std::string& value);
  inline void add_vecsignalfiles(const char* value);
  inline void add_vecsignalfiles(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& vecsignalfiles() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_vecsignalfiles();
  
  // repeated .sln.signal signals = 3;
  inline int signals_size() const;
  inline void clear_signals();
  static const int kSignalsFieldNumber = 3;
  inline const ::sln::signal& signals(int index) const;
  inline ::sln::signal* mutable_signals(int index);
  inline ::sln::signal* add_signals();
  inline const ::google::protobuf::RepeatedPtrField< ::sln::signal >&
      signals() const;
  inline ::google::protobuf::RepeatedPtrField< ::sln::signal >*
      mutable_signals();
  
  // repeated bool broad_sig = 4;
  inline int broad_sig_size() const;
  inline void clear_broad_sig();
  static const int kBroadSigFieldNumber = 4;
  inline bool broad_sig(int index) const;
  inline void set_broad_sig(int index, bool value);
  inline void add_broad_sig(bool value);
  inline const ::google::protobuf::RepeatedField< bool >&
      broad_sig() const;
  inline ::google::protobuf::RepeatedField< bool >*
      mutable_broad_sig();
  
  // @@protoc_insertion_point(class_scope:sln.basis)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* strbasispath_;
  static const ::std::string _default_strbasispath_;
  ::google::protobuf::RepeatedPtrField< ::std::string> vecsignalfiles_;
  ::google::protobuf::RepeatedPtrField< ::sln::signal > signals_;
  ::google::protobuf::RepeatedField< bool > broad_sig_;
  friend void  protobuf_AddDesc_tarquin_2eproto();
  friend void protobuf_AssignDesc_tarquin_2eproto();
  friend void protobuf_ShutdownFile_tarquin_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static basis* default_instance_;
};
// -------------------------------------------------------------------

class options : public ::google::protobuf::Message {
 public:
  options();
  virtual ~options();
  
  options(const options& from);
  
  inline options& operator=(const options& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const options& default_instance();
  
  void Swap(options* other);
  
  // implements Message ----------------------------------------------
  
  options* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const options& from);
  void MergeFrom(const options& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef options_fidformat fidformat;
  static const fidformat DANGER = options_fidformat_DANGER;
  static const fidformat SIEMENS = options_fidformat_SIEMENS;
  static const fidformat PHILIPS = options_fidformat_PHILIPS;
  static const fidformat GE = options_fidformat_GE;
  static const fidformat RDA = options_fidformat_RDA;
  static const fidformat LCM = options_fidformat_LCM;
  static const fidformat SHF = options_fidformat_SHF;
  static const fidformat VARIAN = options_fidformat_VARIAN;
  static const fidformat BRUKER = options_fidformat_BRUKER;
  static const fidformat DCM = options_fidformat_DCM;
  static const fidformat PHILIPS_DCM = options_fidformat_PHILIPS_DCM;
  static const fidformat JMRUI_TXT = options_fidformat_JMRUI_TXT;
  static const fidformat NOTSET = options_fidformat_NOTSET;
  static inline bool fidformat_IsValid(int value) {
    return options_fidformat_IsValid(value);
  }
  static const fidformat fidformat_MIN =
    options_fidformat_fidformat_MIN;
  static const fidformat fidformat_MAX =
    options_fidformat_fidformat_MAX;
  static const int fidformat_ARRAYSIZE =
    options_fidformat_fidformat_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  fidformat_descriptor() {
    return options_fidformat_descriptor();
  }
  static inline const ::std::string& fidformat_Name(fidformat value) {
    return options_fidformat_Name(value);
  }
  static inline bool fidformat_Parse(const ::std::string& name,
      fidformat* value) {
    return options_fidformat_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // optional .sln.options.fidformat format = 1;
  inline bool has_format() const;
  inline void clear_format();
  static const int kFormatFieldNumber = 1;
  inline ::sln::options_fidformat format() const;
  inline void set_format(::sln::options_fidformat value);
  
  // optional string strbasispath = 2;
  inline bool has_strbasispath() const;
  inline void clear_strbasispath();
  static const int kStrbasispathFieldNumber = 2;
  inline const ::std::string& strbasispath() const;
  inline void set_strbasispath(const ::std::string& value);
  inline void set_strbasispath(const char* value);
  inline void set_strbasispath(const char* value, size_t size);
  inline ::std::string* mutable_strbasispath();
  
  // optional bool buseprecompiled = 3;
  inline bool has_buseprecompiled() const;
  inline void clear_buseprecompiled();
  static const int kBuseprecompiledFieldNumber = 3;
  inline bool buseprecompiled() const;
  inline void set_buseprecompiled(bool value);
  
  // optional int32 nstart = 4;
  inline bool has_nstart() const;
  inline void clear_nstart();
  static const int kNstartFieldNumber = 4;
  inline ::google::protobuf::int32 nstart() const;
  inline void set_nstart(::google::protobuf::int32 value);
  
  // optional int32 nend = 5;
  inline bool has_nend() const;
  inline void clear_nend();
  static const int kNendFieldNumber = 5;
  inline ::google::protobuf::int32 nend() const;
  inline void set_nend(::google::protobuf::int32 value);
  
  // optional double phi0_lower = 6;
  inline bool has_phi0_lower() const;
  inline void clear_phi0_lower();
  static const int kPhi0LowerFieldNumber = 6;
  inline double phi0_lower() const;
  inline void set_phi0_lower(double value);
  
  // optional double phi0_upper = 7;
  inline bool has_phi0_upper() const;
  inline void clear_phi0_upper();
  static const int kPhi0UpperFieldNumber = 7;
  inline double phi0_upper() const;
  inline void set_phi0_upper(double value);
  
  // optional double phi0_typ = 8;
  inline bool has_phi0_typ() const;
  inline void clear_phi0_typ();
  static const int kPhi0TypFieldNumber = 8;
  inline double phi0_typ() const;
  inline void set_phi0_typ(double value);
  
  // optional double phi1_lower = 9;
  inline bool has_phi1_lower() const;
  inline void clear_phi1_lower();
  static const int kPhi1LowerFieldNumber = 9;
  inline double phi1_lower() const;
  inline void set_phi1_lower(double value);
  
  // optional double phi1_upper = 10;
  inline bool has_phi1_upper() const;
  inline void clear_phi1_upper();
  static const int kPhi1UpperFieldNumber = 10;
  inline double phi1_upper() const;
  inline void set_phi1_upper(double value);
  
  // optional double phi1_typ = 11;
  inline bool has_phi1_typ() const;
  inline void clear_phi1_typ();
  static const int kPhi1TypFieldNumber = 11;
  inline double phi1_typ() const;
  inline void set_phi1_typ(double value);
  
  // repeated .sln.constraints cons = 12;
  inline int cons_size() const;
  inline void clear_cons();
  static const int kConsFieldNumber = 12;
  inline const ::sln::constraints& cons(int index) const;
  inline ::sln::constraints* mutable_cons(int index);
  inline ::sln::constraints* add_cons();
  inline const ::google::protobuf::RepeatedPtrField< ::sln::constraints >&
      cons() const;
  inline ::google::protobuf::RepeatedPtrField< ::sln::constraints >*
      mutable_cons();
  
  // optional string stroutputxmlpath = 13;
  inline bool has_stroutputxmlpath() const;
  inline void clear_stroutputxmlpath();
  static const int kStroutputxmlpathFieldNumber = 13;
  inline const ::std::string& stroutputxmlpath() const;
  inline void set_stroutputxmlpath(const ::std::string& value);
  inline void set_stroutputxmlpath(const char* value);
  inline void set_stroutputxmlpath(const char* value, size_t size);
  inline ::std::string* mutable_stroutputxmlpath();
  
  // optional string strfile = 14;
  inline bool has_strfile() const;
  inline void clear_strfile();
  static const int kStrfileFieldNumber = 14;
  inline const ::std::string& strfile() const;
  inline void set_strfile(const ::std::string& value);
  inline void set_strfile(const char* value);
  inline void set_strfile(const char* value, size_t size);
  inline ::std::string* mutable_strfile();
  
  // optional string strfilewater = 15;
  inline bool has_strfilewater() const;
  inline void clear_strfilewater();
  static const int kStrfilewaterFieldNumber = 15;
  inline const ::std::string& strfilewater() const;
  inline void set_strfilewater(const ::std::string& value);
  inline void set_strfilewater(const char* value);
  inline void set_strfilewater(const char* value, size_t size);
  inline ::std::string* mutable_strfilewater();
  
  // optional string strfileoutimag = 16;
  inline bool has_strfileoutimag() const;
  inline void clear_strfileoutimag();
  static const int kStrfileoutimagFieldNumber = 16;
  inline const ::std::string& strfileoutimag() const;
  inline void set_strfileoutimag(const ::std::string& value);
  inline void set_strfileoutimag(const char* value);
  inline void set_strfileoutimag(const char* value, size_t size);
  inline ::std::string* mutable_strfileoutimag();
  
  // optional string strfileouttxt = 17;
  inline bool has_strfileouttxt() const;
  inline void clear_strfileouttxt();
  static const int kStrfileouttxtFieldNumber = 17;
  inline const ::std::string& strfileouttxt() const;
  inline void set_strfileouttxt(const ::std::string& value);
  inline void set_strfileouttxt(const char* value);
  inline void set_strfileouttxt(const char* value, size_t size);
  inline ::std::string* mutable_strfileouttxt();
  
  // optional string strfileoutcsv = 18;
  inline bool has_strfileoutcsv() const;
  inline void clear_strfileoutcsv();
  static const int kStrfileoutcsvFieldNumber = 18;
  inline const ::std::string& strfileoutcsv() const;
  inline void set_strfileoutcsv(const ::std::string& value);
  inline void set_strfileoutcsv(const char* value);
  inline void set_strfileoutcsv(const char* value, size_t size);
  inline ::std::string* mutable_strfileoutcsv();
  
  // optional int32 conv_window_width = 19;
  inline bool has_conv_window_width() const;
  inline void clear_conv_window_width();
  static const int kConvWindowWidthFieldNumber = 19;
  inline ::google::protobuf::int32 conv_window_width() const;
  inline void set_conv_window_width(::google::protobuf::int32 value);
  
  // optional int32 water_window = 20;
  inline bool has_water_window() const;
  inline void clear_water_window();
  static const int kWaterWindowFieldNumber = 20;
  inline ::google::protobuf::int32 water_window() const;
  inline void set_water_window(::google::protobuf::int32 value);
  
  // optional bool bautophase = 21;
  inline bool has_bautophase() const;
  inline void clear_bautophase();
  static const int kBautophaseFieldNumber = 21;
  inline bool bautophase() const;
  inline void set_bautophase(bool value);
  
  // optional bool bautoref = 22;
  inline bool has_bautoref() const;
  inline void clear_bautoref();
  static const int kBautorefFieldNumber = 22;
  inline bool bautoref() const;
  inline void set_bautoref(bool value);
  
  // optional bool bShowPreprocessed = 23;
  inline bool has_bshowpreprocessed() const;
  inline void clear_bshowpreprocessed();
  static const int kBShowPreprocessedFieldNumber = 23;
  inline bool bshowpreprocessed() const;
  inline void set_bshowpreprocessed(bool value);
  
  // optional double ref = 24;
  inline bool has_ref() const;
  inline void clear_ref();
  static const int kRefFieldNumber = 24;
  inline double ref() const;
  inline void set_ref(double value);
  
  // optional double ref_spec = 25;
  inline bool has_ref_spec() const;
  inline void clear_ref_spec();
  static const int kRefSpecFieldNumber = 25;
  inline double ref_spec() const;
  inline void set_ref_spec(double value);
  
  // repeated .sln.coord fit_list = 26;
  inline int fit_list_size() const;
  inline void clear_fit_list();
  static const int kFitListFieldNumber = 26;
  inline const ::sln::coord& fit_list(int index) const;
  inline ::sln::coord* mutable_fit_list(int index);
  inline ::sln::coord* add_fit_list();
  inline const ::google::protobuf::RepeatedPtrField< ::sln::coord >&
      fit_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::sln::coord >*
      mutable_fit_list();
  
  // @@protoc_insertion_point(class_scope:sln.options)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  int format_;
  ::std::string* strbasispath_;
  static const ::std::string _default_strbasispath_;
  bool buseprecompiled_;
  ::google::protobuf::int32 nstart_;
  ::google::protobuf::int32 nend_;
  double phi0_lower_;
  double phi0_upper_;
  double phi0_typ_;
  double phi1_lower_;
  double phi1_upper_;
  double phi1_typ_;
  ::google::protobuf::RepeatedPtrField< ::sln::constraints > cons_;
  ::std::string* stroutputxmlpath_;
  static const ::std::string _default_stroutputxmlpath_;
  ::std::string* strfile_;
  static const ::std::string _default_strfile_;
  ::std::string* strfilewater_;
  static const ::std::string _default_strfilewater_;
  ::std::string* strfileoutimag_;
  static const ::std::string _default_strfileoutimag_;
  ::std::string* strfileouttxt_;
  static const ::std::string _default_strfileouttxt_;
  ::std::string* strfileoutcsv_;
  static const ::std::string _default_strfileoutcsv_;
  ::google::protobuf::int32 conv_window_width_;
  ::google::protobuf::int32 water_window_;
  bool bautophase_;
  bool bautoref_;
  bool bshowpreprocessed_;
  double ref_;
  double ref_spec_;
  ::google::protobuf::RepeatedPtrField< ::sln::coord > fit_list_;
  friend void  protobuf_AddDesc_tarquin_2eproto();
  friend void protobuf_AssignDesc_tarquin_2eproto();
  friend void protobuf_ShutdownFile_tarquin_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(26 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static options* default_instance_;
};
// -------------------------------------------------------------------

class constraints : public ::google::protobuf::Message {
 public:
  constraints();
  virtual ~constraints();
  
  constraints(const constraints& from);
  
  inline constraints& operator=(const constraints& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const constraints& default_instance();
  
  void Swap(constraints* other);
  
  // implements Message ----------------------------------------------
  
  constraints* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const constraints& from);
  void MergeFrom(const constraints& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional double minalpha = 1;
  inline bool has_minalpha() const;
  inline void clear_minalpha();
  static const int kMinalphaFieldNumber = 1;
  inline double minalpha() const;
  inline void set_minalpha(double value);
  
  // optional double maxalpha = 2;
  inline bool has_maxalpha() const;
  inline void clear_maxalpha();
  static const int kMaxalphaFieldNumber = 2;
  inline double maxalpha() const;
  inline void set_maxalpha(double value);
  
  // optional double typalpha = 3;
  inline bool has_typalpha() const;
  inline void clear_typalpha();
  static const int kTypalphaFieldNumber = 3;
  inline double typalpha() const;
  inline void set_typalpha(double value);
  
  // optional double minbeta = 4;
  inline bool has_minbeta() const;
  inline void clear_minbeta();
  static const int kMinbetaFieldNumber = 4;
  inline double minbeta() const;
  inline void set_minbeta(double value);
  
  // optional double maxbeta = 5;
  inline bool has_maxbeta() const;
  inline void clear_maxbeta();
  static const int kMaxbetaFieldNumber = 5;
  inline double maxbeta() const;
  inline void set_maxbeta(double value);
  
  // optional double typbeta = 6;
  inline bool has_typbeta() const;
  inline void clear_typbeta();
  static const int kTypbetaFieldNumber = 6;
  inline double typbeta() const;
  inline void set_typbeta(double value);
  
  // optional double minshifthz = 7;
  inline bool has_minshifthz() const;
  inline void clear_minshifthz();
  static const int kMinshifthzFieldNumber = 7;
  inline double minshifthz() const;
  inline void set_minshifthz(double value);
  
  // optional double maxshifthz = 8;
  inline bool has_maxshifthz() const;
  inline void clear_maxshifthz();
  static const int kMaxshifthzFieldNumber = 8;
  inline double maxshifthz() const;
  inline void set_maxshifthz(double value);
  
  // optional double typshifthz = 9;
  inline bool has_typshifthz() const;
  inline void clear_typshifthz();
  static const int kTypshifthzFieldNumber = 9;
  inline double typshifthz() const;
  inline void set_typshifthz(double value);
  
  // @@protoc_insertion_point(class_scope:sln.constraints)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  double minalpha_;
  double maxalpha_;
  double typalpha_;
  double minbeta_;
  double maxbeta_;
  double typbeta_;
  double minshifthz_;
  double maxshifthz_;
  double typshifthz_;
  friend void  protobuf_AddDesc_tarquin_2eproto();
  friend void protobuf_AssignDesc_tarquin_2eproto();
  friend void protobuf_ShutdownFile_tarquin_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static constraints* default_instance_;
};
// ===================================================================


// ===================================================================

// results

// optional .sln.fid fidraw = 1;
inline bool results::has_fidraw() const {
  return _has_bit(0);
}
inline void results::clear_fidraw() {
  if (fidraw_ != NULL) fidraw_->::sln::fid::Clear();
  _clear_bit(0);
}
inline const ::sln::fid& results::fidraw() const {
  return fidraw_ != NULL ? *fidraw_ : *default_instance_->fidraw_;
}
inline ::sln::fid* results::mutable_fidraw() {
  _set_bit(0);
  if (fidraw_ == NULL) fidraw_ = new ::sln::fid;
  return fidraw_;
}

// optional .sln.fid fidproc = 2;
inline bool results::has_fidproc() const {
  return _has_bit(1);
}
inline void results::clear_fidproc() {
  if (fidproc_ != NULL) fidproc_->::sln::fid::Clear();
  _clear_bit(1);
}
inline const ::sln::fid& results::fidproc() const {
  return fidproc_ != NULL ? *fidproc_ : *default_instance_->fidproc_;
}
inline ::sln::fid* results::mutable_fidproc() {
  _set_bit(1);
  if (fidproc_ == NULL) fidproc_ = new ::sln::fid;
  return fidproc_;
}

// optional .sln.fid fidwater = 3;
inline bool results::has_fidwater() const {
  return _has_bit(2);
}
inline void results::clear_fidwater() {
  if (fidwater_ != NULL) fidwater_->::sln::fid::Clear();
  _clear_bit(2);
}
inline const ::sln::fid& results::fidwater() const {
  return fidwater_ != NULL ? *fidwater_ : *default_instance_->fidwater_;
}
inline ::sln::fid* results::mutable_fidwater() {
  _set_bit(2);
  if (fidwater_ == NULL) fidwater_ = new ::sln::fid;
  return fidwater_;
}

// optional .sln.basis basis = 4;
inline bool results::has_basis() const {
  return _has_bit(3);
}
inline void results::clear_basis() {
  if (basis_ != NULL) basis_->::sln::basis::Clear();
  _clear_bit(3);
}
inline const ::sln::basis& results::basis() const {
  return basis_ != NULL ? *basis_ : *default_instance_->basis_;
}
inline ::sln::basis* results::mutable_basis() {
  _set_bit(3);
  if (basis_ == NULL) basis_ = new ::sln::basis;
  return basis_;
}

// optional .sln.options options = 5;
inline bool results::has_options() const {
  return _has_bit(4);
}
inline void results::clear_options() {
  if (options_ != NULL) options_->::sln::options::Clear();
  _clear_bit(4);
}
inline const ::sln::options& results::options() const {
  return options_ != NULL ? *options_ : *default_instance_->options_;
}
inline ::sln::options* results::mutable_options() {
  _set_bit(4);
  if (options_ == NULL) options_ = new ::sln::options;
  return options_;
}

// repeated .sln.comp_vec yhat = 6;
inline int results::yhat_size() const {
  return yhat_.size();
}
inline void results::clear_yhat() {
  yhat_.Clear();
}
inline const ::sln::comp_vec& results::yhat(int index) const {
  return yhat_.Get(index);
}
inline ::sln::comp_vec* results::mutable_yhat(int index) {
  return yhat_.Mutable(index);
}
inline ::sln::comp_vec* results::add_yhat() {
  return yhat_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sln::comp_vec >&
results::yhat() const {
  return yhat_;
}
inline ::google::protobuf::RepeatedPtrField< ::sln::comp_vec >*
results::mutable_yhat() {
  return &yhat_;
}

// repeated .sln.vec amplitudes = 7;
inline int results::amplitudes_size() const {
  return amplitudes_.size();
}
inline void results::clear_amplitudes() {
  amplitudes_.Clear();
}
inline const ::sln::vec& results::amplitudes(int index) const {
  return amplitudes_.Get(index);
}
inline ::sln::vec* results::mutable_amplitudes(int index) {
  return amplitudes_.Mutable(index);
}
inline ::sln::vec* results::add_amplitudes() {
  return amplitudes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sln::vec >&
results::amplitudes() const {
  return amplitudes_;
}
inline ::google::protobuf::RepeatedPtrField< ::sln::vec >*
results::mutable_amplitudes() {
  return &amplitudes_;
}

// repeated .sln.comp_mat matgroups = 8;
inline int results::matgroups_size() const {
  return matgroups_.size();
}
inline void results::clear_matgroups() {
  matgroups_.Clear();
}
inline const ::sln::comp_mat& results::matgroups(int index) const {
  return matgroups_.Get(index);
}
inline ::sln::comp_mat* results::mutable_matgroups(int index) {
  return matgroups_.Mutable(index);
}
inline ::sln::comp_mat* results::add_matgroups() {
  return matgroups_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sln::comp_mat >&
results::matgroups() const {
  return matgroups_;
}
inline ::google::protobuf::RepeatedPtrField< ::sln::comp_mat >*
results::mutable_matgroups() {
  return &matgroups_;
}

// repeated .sln.comp_mat matbasis = 9;
inline int results::matbasis_size() const {
  return matbasis_.size();
}
inline void results::clear_matbasis() {
  matbasis_.Clear();
}
inline const ::sln::comp_mat& results::matbasis(int index) const {
  return matbasis_.Get(index);
}
inline ::sln::comp_mat* results::mutable_matbasis(int index) {
  return matbasis_.Mutable(index);
}
inline ::sln::comp_mat* results::add_matbasis() {
  return matbasis_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sln::comp_mat >&
results::matbasis() const {
  return matbasis_;
}
inline ::google::protobuf::RepeatedPtrField< ::sln::comp_mat >*
results::mutable_matbasis() {
  return &matbasis_;
}

// repeated double lm_opts = 10;
inline int results::lm_opts_size() const {
  return lm_opts_.size();
}
inline void results::clear_lm_opts() {
  lm_opts_.Clear();
}
inline double results::lm_opts(int index) const {
  return lm_opts_.Get(index);
}
inline void results::set_lm_opts(int index, double value) {
  lm_opts_.Set(index, value);
}
inline void results::add_lm_opts(double value) {
  lm_opts_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
results::lm_opts() const {
  return lm_opts_;
}
inline ::google::protobuf::RepeatedField< double >*
results::mutable_lm_opts() {
  return &lm_opts_;
}

// repeated .sln.vec lm_info = 11;
inline int results::lm_info_size() const {
  return lm_info_.size();
}
inline void results::clear_lm_info() {
  lm_info_.Clear();
}
inline const ::sln::vec& results::lm_info(int index) const {
  return lm_info_.Get(index);
}
inline ::sln::vec* results::mutable_lm_info(int index) {
  return lm_info_.Mutable(index);
}
inline ::sln::vec* results::add_lm_info() {
  return lm_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sln::vec >&
results::lm_info() const {
  return lm_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::sln::vec >*
results::mutable_lm_info() {
  return &lm_info_;
}

// repeated double norm_val = 12;
inline int results::norm_val_size() const {
  return norm_val_.size();
}
inline void results::clear_norm_val() {
  norm_val_.Clear();
}
inline double results::norm_val(int index) const {
  return norm_val_.Get(index);
}
inline void results::set_norm_val(int index, double value) {
  norm_val_.Set(index, value);
}
inline void results::add_norm_val(double value) {
  norm_val_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
results::norm_val() const {
  return norm_val_;
}
inline ::google::protobuf::RepeatedField< double >*
results::mutable_norm_val() {
  return &norm_val_;
}

// repeated .sln.vec crlbs = 13;
inline int results::crlbs_size() const {
  return crlbs_.size();
}
inline void results::clear_crlbs() {
  crlbs_.Clear();
}
inline const ::sln::vec& results::crlbs(int index) const {
  return crlbs_.Get(index);
}
inline ::sln::vec* results::mutable_crlbs(int index) {
  return crlbs_.Mutable(index);
}
inline ::sln::vec* results::add_crlbs() {
  return crlbs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sln::vec >&
results::crlbs() const {
  return crlbs_;
}
inline ::google::protobuf::RepeatedPtrField< ::sln::vec >*
results::mutable_crlbs() {
  return &crlbs_;
}

// repeated double q = 14;
inline int results::q_size() const {
  return q_.size();
}
inline void results::clear_q() {
  q_.Clear();
}
inline double results::q(int index) const {
  return q_.Get(index);
}
inline void results::set_q(int index, double value) {
  q_.Set(index, value);
}
inline void results::add_q(double value) {
  q_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
results::q() const {
  return q_;
}
inline ::google::protobuf::RepeatedField< double >*
results::mutable_q() {
  return &q_;
}

// repeated .sln.vec amp_norm = 15;
inline int results::amp_norm_size() const {
  return amp_norm_.size();
}
inline void results::clear_amp_norm() {
  amp_norm_.Clear();
}
inline const ::sln::vec& results::amp_norm(int index) const {
  return amp_norm_.Get(index);
}
inline ::sln::vec* results::mutable_amp_norm(int index) {
  return amp_norm_.Mutable(index);
}
inline ::sln::vec* results::add_amp_norm() {
  return amp_norm_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sln::vec >&
results::amp_norm() const {
  return amp_norm_;
}
inline ::google::protobuf::RepeatedPtrField< ::sln::vec >*
results::mutable_amp_norm() {
  return &amp_norm_;
}

// repeated .sln.vec crlbs_norm = 16;
inline int results::crlbs_norm_size() const {
  return crlbs_norm_.size();
}
inline void results::clear_crlbs_norm() {
  crlbs_norm_.Clear();
}
inline const ::sln::vec& results::crlbs_norm(int index) const {
  return crlbs_norm_.Get(index);
}
inline ::sln::vec* results::mutable_crlbs_norm(int index) {
  return crlbs_norm_.Mutable(index);
}
inline ::sln::vec* results::add_crlbs_norm() {
  return crlbs_norm_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sln::vec >&
results::crlbs_norm() const {
  return crlbs_norm_;
}
inline ::google::protobuf::RepeatedPtrField< ::sln::vec >*
results::mutable_crlbs_norm() {
  return &crlbs_norm_;
}

// -------------------------------------------------------------------

// fid

// optional string strfilename = 1;
inline bool fid::has_strfilename() const {
  return _has_bit(0);
}
inline void fid::clear_strfilename() {
  if (strfilename_ != &_default_strfilename_) {
    strfilename_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& fid::strfilename() const {
  return *strfilename_;
}
inline void fid::set_strfilename(const ::std::string& value) {
  _set_bit(0);
  if (strfilename_ == &_default_strfilename_) {
    strfilename_ = new ::std::string;
  }
  strfilename_->assign(value);
}
inline void fid::set_strfilename(const char* value) {
  _set_bit(0);
  if (strfilename_ == &_default_strfilename_) {
    strfilename_ = new ::std::string;
  }
  strfilename_->assign(value);
}
inline void fid::set_strfilename(const char* value, size_t size) {
  _set_bit(0);
  if (strfilename_ == &_default_strfilename_) {
    strfilename_ = new ::std::string;
  }
  strfilename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* fid::mutable_strfilename() {
  _set_bit(0);
  if (strfilename_ == &_default_strfilename_) {
    strfilename_ = new ::std::string;
  }
  return strfilename_;
}

// optional double fs = 2;
inline bool fid::has_fs() const {
  return _has_bit(1);
}
inline void fid::clear_fs() {
  fs_ = 0;
  _clear_bit(1);
}
inline double fid::fs() const {
  return fs_;
}
inline void fid::set_fs(double value) {
  _set_bit(1);
  fs_ = value;
}

// optional bool bsamplingfrequencyknown = 3;
inline bool fid::has_bsamplingfrequencyknown() const {
  return _has_bit(2);
}
inline void fid::clear_bsamplingfrequencyknown() {
  bsamplingfrequencyknown_ = false;
  _clear_bit(2);
}
inline bool fid::bsamplingfrequencyknown() const {
  return bsamplingfrequencyknown_;
}
inline void fid::set_bsamplingfrequencyknown(bool value) {
  _set_bit(2);
  bsamplingfrequencyknown_ = value;
}

// optional double ft = 4;
inline bool fid::has_ft() const {
  return _has_bit(3);
}
inline void fid::clear_ft() {
  ft_ = 0;
  _clear_bit(3);
}
inline double fid::ft() const {
  return ft_;
}
inline void fid::set_ft(double value) {
  _set_bit(3);
  ft_ = value;
}

// optional bool btransmitterfrequencyknown = 5;
inline bool fid::has_btransmitterfrequencyknown() const {
  return _has_bit(4);
}
inline void fid::clear_btransmitterfrequencyknown() {
  btransmitterfrequencyknown_ = false;
  _clear_bit(4);
}
inline bool fid::btransmitterfrequencyknown() const {
  return btransmitterfrequencyknown_;
}
inline void fid::set_btransmitterfrequencyknown(bool value) {
  _set_bit(4);
  btransmitterfrequencyknown_ = value;
}

// optional string strsequence = 6;
inline bool fid::has_strsequence() const {
  return _has_bit(5);
}
inline void fid::clear_strsequence() {
  if (strsequence_ != &_default_strsequence_) {
    strsequence_->clear();
  }
  _clear_bit(5);
}
inline const ::std::string& fid::strsequence() const {
  return *strsequence_;
}
inline void fid::set_strsequence(const ::std::string& value) {
  _set_bit(5);
  if (strsequence_ == &_default_strsequence_) {
    strsequence_ = new ::std::string;
  }
  strsequence_->assign(value);
}
inline void fid::set_strsequence(const char* value) {
  _set_bit(5);
  if (strsequence_ == &_default_strsequence_) {
    strsequence_ = new ::std::string;
  }
  strsequence_->assign(value);
}
inline void fid::set_strsequence(const char* value, size_t size) {
  _set_bit(5);
  if (strsequence_ == &_default_strsequence_) {
    strsequence_ = new ::std::string;
  }
  strsequence_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* fid::mutable_strsequence() {
  _set_bit(5);
  if (strsequence_ == &_default_strsequence_) {
    strsequence_ = new ::std::string;
  }
  return strsequence_;
}

// optional bool pulsesequenceknown = 7;
inline bool fid::has_pulsesequenceknown() const {
  return _has_bit(6);
}
inline void fid::clear_pulsesequenceknown() {
  pulsesequenceknown_ = false;
  _clear_bit(6);
}
inline bool fid::pulsesequenceknown() const {
  return pulsesequenceknown_;
}
inline void fid::set_pulsesequenceknown(bool value) {
  _set_bit(6);
  pulsesequenceknown_ = value;
}

// optional int32 naverages = 8;
inline bool fid::has_naverages() const {
  return _has_bit(7);
}
inline void fid::clear_naverages() {
  naverages_ = 0;
  _clear_bit(7);
}
inline ::google::protobuf::int32 fid::naverages() const {
  return naverages_;
}
inline void fid::set_naverages(::google::protobuf::int32 value) {
  _set_bit(7);
  naverages_ = value;
}

// optional bool baveragesknown = 9;
inline bool fid::has_baveragesknown() const {
  return _has_bit(8);
}
inline void fid::clear_baveragesknown() {
  baveragesknown_ = false;
  _clear_bit(8);
}
inline bool fid::baveragesknown() const {
  return baveragesknown_;
}
inline void fid::set_baveragesknown(bool value) {
  _set_bit(8);
  baveragesknown_ = value;
}

// repeated double phi0 = 10;
inline int fid::phi0_size() const {
  return phi0_.size();
}
inline void fid::clear_phi0() {
  phi0_.Clear();
}
inline double fid::phi0(int index) const {
  return phi0_.Get(index);
}
inline void fid::set_phi0(int index, double value) {
  phi0_.Set(index, value);
}
inline void fid::add_phi0(double value) {
  phi0_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
fid::phi0() const {
  return phi0_;
}
inline ::google::protobuf::RepeatedField< double >*
fid::mutable_phi0() {
  return &phi0_;
}

// repeated bool bzeroorderphaseknown = 11;
inline int fid::bzeroorderphaseknown_size() const {
  return bzeroorderphaseknown_.size();
}
inline void fid::clear_bzeroorderphaseknown() {
  bzeroorderphaseknown_.Clear();
}
inline bool fid::bzeroorderphaseknown(int index) const {
  return bzeroorderphaseknown_.Get(index);
}
inline void fid::set_bzeroorderphaseknown(int index, bool value) {
  bzeroorderphaseknown_.Set(index, value);
}
inline void fid::add_bzeroorderphaseknown(bool value) {
  bzeroorderphaseknown_.Add(value);
}
inline const ::google::protobuf::RepeatedField< bool >&
fid::bzeroorderphaseknown() const {
  return bzeroorderphaseknown_;
}
inline ::google::protobuf::RepeatedField< bool >*
fid::mutable_bzeroorderphaseknown() {
  return &bzeroorderphaseknown_;
}

// repeated double phi1 = 12;
inline int fid::phi1_size() const {
  return phi1_.size();
}
inline void fid::clear_phi1() {
  phi1_.Clear();
}
inline double fid::phi1(int index) const {
  return phi1_.Get(index);
}
inline void fid::set_phi1(int index, double value) {
  phi1_.Set(index, value);
}
inline void fid::add_phi1(double value) {
  phi1_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
fid::phi1() const {
  return phi1_;
}
inline ::google::protobuf::RepeatedField< double >*
fid::mutable_phi1() {
  return &phi1_;
}

// repeated bool bfirstorderphaseknown = 13;
inline int fid::bfirstorderphaseknown_size() const {
  return bfirstorderphaseknown_.size();
}
inline void fid::clear_bfirstorderphaseknown() {
  bfirstorderphaseknown_.Clear();
}
inline bool fid::bfirstorderphaseknown(int index) const {
  return bfirstorderphaseknown_.Get(index);
}
inline void fid::set_bfirstorderphaseknown(int index, bool value) {
  bfirstorderphaseknown_.Set(index, value);
}
inline void fid::add_bfirstorderphaseknown(bool value) {
  bfirstorderphaseknown_.Add(value);
}
inline const ::google::protobuf::RepeatedField< bool >&
fid::bfirstorderphaseknown() const {
  return bfirstorderphaseknown_;
}
inline ::google::protobuf::RepeatedField< bool >*
fid::mutable_bfirstorderphaseknown() {
  return &bfirstorderphaseknown_;
}

// repeated double ref = 14;
inline int fid::ref_size() const {
  return ref_.size();
}
inline void fid::clear_ref() {
  ref_.Clear();
}
inline double fid::ref(int index) const {
  return ref_.Get(index);
}
inline void fid::set_ref(int index, double value) {
  ref_.Set(index, value);
}
inline void fid::add_ref(double value) {
  ref_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
fid::ref() const {
  return ref_;
}
inline ::google::protobuf::RepeatedField< double >*
fid::mutable_ref() {
  return &ref_;
}

// repeated bool breferenceknown = 15;
inline int fid::breferenceknown_size() const {
  return breferenceknown_.size();
}
inline void fid::clear_breferenceknown() {
  breferenceknown_.Clear();
}
inline bool fid::breferenceknown(int index) const {
  return breferenceknown_.Get(index);
}
inline void fid::set_breferenceknown(int index, bool value) {
  breferenceknown_.Set(index, value);
}
inline void fid::add_breferenceknown(bool value) {
  breferenceknown_.Add(value);
}
inline const ::google::protobuf::RepeatedField< bool >&
fid::breferenceknown() const {
  return breferenceknown_;
}
inline ::google::protobuf::RepeatedField< bool >*
fid::mutable_breferenceknown() {
  return &breferenceknown_;
}

// optional double tau = 16;
inline bool fid::has_tau() const {
  return _has_bit(15);
}
inline void fid::clear_tau() {
  tau_ = 0;
  _clear_bit(15);
}
inline double fid::tau() const {
  return tau_;
}
inline void fid::set_tau(double value) {
  _set_bit(15);
  tau_ = value;
}

// optional bool bechoknown = 17;
inline bool fid::has_bechoknown() const {
  return _has_bit(16);
}
inline void fid::clear_bechoknown() {
  bechoknown_ = false;
  _clear_bit(16);
}
inline bool fid::bechoknown() const {
  return bechoknown_;
}
inline void fid::set_bechoknown(bool value) {
  _set_bit(16);
  bechoknown_ = value;
}

// repeated double snr = 18;
inline int fid::snr_size() const {
  return snr_.size();
}
inline void fid::clear_snr() {
  snr_.Clear();
}
inline double fid::snr(int index) const {
  return snr_.Get(index);
}
inline void fid::set_snr(int index, double value) {
  snr_.Set(index, value);
}
inline void fid::add_snr(double value) {
  snr_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
fid::snr() const {
  return snr_;
}
inline ::google::protobuf::RepeatedField< double >*
fid::mutable_snr() {
  return &snr_;
}

// repeated bool bsnrknown = 19;
inline int fid::bsnrknown_size() const {
  return bsnrknown_.size();
}
inline void fid::clear_bsnrknown() {
  bsnrknown_.Clear();
}
inline bool fid::bsnrknown(int index) const {
  return bsnrknown_.Get(index);
}
inline void fid::set_bsnrknown(int index, bool value) {
  bsnrknown_.Set(index, value);
}
inline void fid::add_bsnrknown(bool value) {
  bsnrknown_.Add(value);
}
inline const ::google::protobuf::RepeatedField< bool >&
fid::bsnrknown() const {
  return bsnrknown_;
}
inline ::google::protobuf::RepeatedField< bool >*
fid::mutable_bsnrknown() {
  return &bsnrknown_;
}

// optional int32 npoints = 20;
inline bool fid::has_npoints() const {
  return _has_bit(19);
}
inline void fid::clear_npoints() {
  npoints_ = 0;
  _clear_bit(19);
}
inline ::google::protobuf::int32 fid::npoints() const {
  return npoints_;
}
inline void fid::set_npoints(::google::protobuf::int32 value) {
  _set_bit(19);
  npoints_ = value;
}

// repeated .sln.comp_vec fids = 21;
inline int fid::fids_size() const {
  return fids_.size();
}
inline void fid::clear_fids() {
  fids_.Clear();
}
inline const ::sln::comp_vec& fid::fids(int index) const {
  return fids_.Get(index);
}
inline ::sln::comp_vec* fid::mutable_fids(int index) {
  return fids_.Mutable(index);
}
inline ::sln::comp_vec* fid::add_fids() {
  return fids_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sln::comp_vec >&
fid::fids() const {
  return fids_;
}
inline ::google::protobuf::RepeatedPtrField< ::sln::comp_vec >*
fid::mutable_fids() {
  return &fids_;
}

// optional double norm_val = 22;
inline bool fid::has_norm_val() const {
  return _has_bit(21);
}
inline void fid::clear_norm_val() {
  norm_val_ = 0;
  _clear_bit(21);
}
inline double fid::norm_val() const {
  return norm_val_;
}
inline void fid::set_norm_val(double value) {
  _set_bit(21);
  norm_val_ = value;
}

// optional int32 rows = 23;
inline bool fid::has_rows() const {
  return _has_bit(22);
}
inline void fid::clear_rows() {
  rows_ = 0;
  _clear_bit(22);
}
inline ::google::protobuf::int32 fid::rows() const {
  return rows_;
}
inline void fid::set_rows(::google::protobuf::int32 value) {
  _set_bit(22);
  rows_ = value;
}

// optional int32 cols = 24;
inline bool fid::has_cols() const {
  return _has_bit(23);
}
inline void fid::clear_cols() {
  cols_ = 0;
  _clear_bit(23);
}
inline ::google::protobuf::int32 fid::cols() const {
  return cols_;
}
inline void fid::set_cols(::google::protobuf::int32 value) {
  _set_bit(23);
  cols_ = value;
}

// optional int32 slices = 25;
inline bool fid::has_slices() const {
  return _has_bit(24);
}
inline void fid::clear_slices() {
  slices_ = 0;
  _clear_bit(24);
}
inline ::google::protobuf::int32 fid::slices() const {
  return slices_;
}
inline void fid::set_slices(::google::protobuf::int32 value) {
  _set_bit(24);
  slices_ = value;
}

// optional bool voxel_dim_known = 26;
inline bool fid::has_voxel_dim_known() const {
  return _has_bit(25);
}
inline void fid::clear_voxel_dim_known() {
  voxel_dim_known_ = false;
  _clear_bit(25);
}
inline bool fid::voxel_dim_known() const {
  return voxel_dim_known_;
}
inline void fid::set_voxel_dim_known(bool value) {
  _set_bit(25);
  voxel_dim_known_ = value;
}

// repeated double voxel_dim = 27;
inline int fid::voxel_dim_size() const {
  return voxel_dim_.size();
}
inline void fid::clear_voxel_dim() {
  voxel_dim_.Clear();
}
inline double fid::voxel_dim(int index) const {
  return voxel_dim_.Get(index);
}
inline void fid::set_voxel_dim(int index, double value) {
  voxel_dim_.Set(index, value);
}
inline void fid::add_voxel_dim(double value) {
  voxel_dim_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
fid::voxel_dim() const {
  return voxel_dim_;
}
inline ::google::protobuf::RepeatedField< double >*
fid::mutable_voxel_dim() {
  return &voxel_dim_;
}

// optional bool voi_dim_known = 28;
inline bool fid::has_voi_dim_known() const {
  return _has_bit(27);
}
inline void fid::clear_voi_dim_known() {
  voi_dim_known_ = false;
  _clear_bit(27);
}
inline bool fid::voi_dim_known() const {
  return voi_dim_known_;
}
inline void fid::set_voi_dim_known(bool value) {
  _set_bit(27);
  voi_dim_known_ = value;
}

// repeated double voi_dim = 29;
inline int fid::voi_dim_size() const {
  return voi_dim_.size();
}
inline void fid::clear_voi_dim() {
  voi_dim_.Clear();
}
inline double fid::voi_dim(int index) const {
  return voi_dim_.Get(index);
}
inline void fid::set_voi_dim(int index, double value) {
  voi_dim_.Set(index, value);
}
inline void fid::add_voi_dim(double value) {
  voi_dim_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
fid::voi_dim() const {
  return voi_dim_;
}
inline ::google::protobuf::RepeatedField< double >*
fid::mutable_voi_dim() {
  return &voi_dim_;
}

// optional bool pos_known = 30;
inline bool fid::has_pos_known() const {
  return _has_bit(29);
}
inline void fid::clear_pos_known() {
  pos_known_ = false;
  _clear_bit(29);
}
inline bool fid::pos_known() const {
  return pos_known_;
}
inline void fid::set_pos_known(bool value) {
  _set_bit(29);
  pos_known_ = value;
}

// repeated double pos = 31;
inline int fid::pos_size() const {
  return pos_.size();
}
inline void fid::clear_pos() {
  pos_.Clear();
}
inline double fid::pos(int index) const {
  return pos_.Get(index);
}
inline void fid::set_pos(int index, double value) {
  pos_.Set(index, value);
}
inline void fid::add_pos(double value) {
  pos_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
fid::pos() const {
  return pos_;
}
inline ::google::protobuf::RepeatedField< double >*
fid::mutable_pos() {
  return &pos_;
}

// optional bool row_dirn_known = 32;
inline bool fid::has_row_dirn_known() const {
  return _has_bit(31);
}
inline void fid::clear_row_dirn_known() {
  row_dirn_known_ = false;
  _clear_bit(31);
}
inline bool fid::row_dirn_known() const {
  return row_dirn_known_;
}
inline void fid::set_row_dirn_known(bool value) {
  _set_bit(31);
  row_dirn_known_ = value;
}

// repeated double row_dirn = 33;
inline int fid::row_dirn_size() const {
  return row_dirn_.size();
}
inline void fid::clear_row_dirn() {
  row_dirn_.Clear();
}
inline double fid::row_dirn(int index) const {
  return row_dirn_.Get(index);
}
inline void fid::set_row_dirn(int index, double value) {
  row_dirn_.Set(index, value);
}
inline void fid::add_row_dirn(double value) {
  row_dirn_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
fid::row_dirn() const {
  return row_dirn_;
}
inline ::google::protobuf::RepeatedField< double >*
fid::mutable_row_dirn() {
  return &row_dirn_;
}

// optional bool col_dirn_known = 34;
inline bool fid::has_col_dirn_known() const {
  return _has_bit(33);
}
inline void fid::clear_col_dirn_known() {
  col_dirn_known_ = false;
  _clear_bit(33);
}
inline bool fid::col_dirn_known() const {
  return col_dirn_known_;
}
inline void fid::set_col_dirn_known(bool value) {
  _set_bit(33);
  col_dirn_known_ = value;
}

// repeated double col_dirn = 35;
inline int fid::col_dirn_size() const {
  return col_dirn_.size();
}
inline void fid::clear_col_dirn() {
  col_dirn_.Clear();
}
inline double fid::col_dirn(int index) const {
  return col_dirn_.Get(index);
}
inline void fid::set_col_dirn(int index, double value) {
  col_dirn_.Set(index, value);
}
inline void fid::add_col_dirn(double value) {
  col_dirn_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
fid::col_dirn() const {
  return col_dirn_;
}
inline ::google::protobuf::RepeatedField< double >*
fid::mutable_col_dirn() {
  return &col_dirn_;
}

// -------------------------------------------------------------------

// coord

// optional int32 row = 1;
inline bool coord::has_row() const {
  return _has_bit(0);
}
inline void coord::clear_row() {
  row_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 coord::row() const {
  return row_;
}
inline void coord::set_row(::google::protobuf::int32 value) {
  _set_bit(0);
  row_ = value;
}

// optional int32 col = 2;
inline bool coord::has_col() const {
  return _has_bit(1);
}
inline void coord::clear_col() {
  col_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 coord::col() const {
  return col_;
}
inline void coord::set_col(::google::protobuf::int32 value) {
  _set_bit(1);
  col_ = value;
}

// optional int32 slice = 3;
inline bool coord::has_slice() const {
  return _has_bit(2);
}
inline void coord::clear_slice() {
  slice_ = 0;
  _clear_bit(2);
}
inline ::google::protobuf::int32 coord::slice() const {
  return slice_;
}
inline void coord::set_slice(::google::protobuf::int32 value) {
  _set_bit(2);
  slice_ = value;
}

// -------------------------------------------------------------------

// comp_point

// optional double real = 1;
inline bool comp_point::has_real() const {
  return _has_bit(0);
}
inline void comp_point::clear_real() {
  real_ = 0;
  _clear_bit(0);
}
inline double comp_point::real() const {
  return real_;
}
inline void comp_point::set_real(double value) {
  _set_bit(0);
  real_ = value;
}

// optional double imag = 2;
inline bool comp_point::has_imag() const {
  return _has_bit(1);
}
inline void comp_point::clear_imag() {
  imag_ = 0;
  _clear_bit(1);
}
inline double comp_point::imag() const {
  return imag_;
}
inline void comp_point::set_imag(double value) {
  _set_bit(1);
  imag_ = value;
}

// -------------------------------------------------------------------

// comp_vec

// repeated .sln.comp_point comp_point = 1;
inline int comp_vec::comp_point_size() const {
  return comp_point_.size();
}
inline void comp_vec::clear_comp_point() {
  comp_point_.Clear();
}
inline const ::sln::comp_point& comp_vec::comp_point(int index) const {
  return comp_point_.Get(index);
}
inline ::sln::comp_point* comp_vec::mutable_comp_point(int index) {
  return comp_point_.Mutable(index);
}
inline ::sln::comp_point* comp_vec::add_comp_point() {
  return comp_point_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sln::comp_point >&
comp_vec::comp_point() const {
  return comp_point_;
}
inline ::google::protobuf::RepeatedPtrField< ::sln::comp_point >*
comp_vec::mutable_comp_point() {
  return &comp_point_;
}

// -------------------------------------------------------------------

// comp_mat

// repeated .sln.comp_vec comp_vec = 1;
inline int comp_mat::comp_vec_size() const {
  return comp_vec_.size();
}
inline void comp_mat::clear_comp_vec() {
  comp_vec_.Clear();
}
inline const ::sln::comp_vec& comp_mat::comp_vec(int index) const {
  return comp_vec_.Get(index);
}
inline ::sln::comp_vec* comp_mat::mutable_comp_vec(int index) {
  return comp_vec_.Mutable(index);
}
inline ::sln::comp_vec* comp_mat::add_comp_vec() {
  return comp_vec_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sln::comp_vec >&
comp_mat::comp_vec() const {
  return comp_vec_;
}
inline ::google::protobuf::RepeatedPtrField< ::sln::comp_vec >*
comp_mat::mutable_comp_vec() {
  return &comp_vec_;
}

// -------------------------------------------------------------------

// vec

// repeated double point = 1;
inline int vec::point_size() const {
  return point_.size();
}
inline void vec::clear_point() {
  point_.Clear();
}
inline double vec::point(int index) const {
  return point_.Get(index);
}
inline void vec::set_point(int index, double value) {
  point_.Set(index, value);
}
inline void vec::add_point(double value) {
  point_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
vec::point() const {
  return point_;
}
inline ::google::protobuf::RepeatedField< double >*
vec::mutable_point() {
  return &point_;
}

// -------------------------------------------------------------------

// signal

// repeated .sln.fid fid_vec = 1;
inline int signal::fid_vec_size() const {
  return fid_vec_.size();
}
inline void signal::clear_fid_vec() {
  fid_vec_.Clear();
}
inline const ::sln::fid& signal::fid_vec(int index) const {
  return fid_vec_.Get(index);
}
inline ::sln::fid* signal::mutable_fid_vec(int index) {
  return fid_vec_.Mutable(index);
}
inline ::sln::fid* signal::add_fid_vec() {
  return fid_vec_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sln::fid >&
signal::fid_vec() const {
  return fid_vec_;
}
inline ::google::protobuf::RepeatedPtrField< ::sln::fid >*
signal::mutable_fid_vec() {
  return &fid_vec_;
}

// -------------------------------------------------------------------

// basis

// optional string strbasispath = 1;
inline bool basis::has_strbasispath() const {
  return _has_bit(0);
}
inline void basis::clear_strbasispath() {
  if (strbasispath_ != &_default_strbasispath_) {
    strbasispath_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& basis::strbasispath() const {
  return *strbasispath_;
}
inline void basis::set_strbasispath(const ::std::string& value) {
  _set_bit(0);
  if (strbasispath_ == &_default_strbasispath_) {
    strbasispath_ = new ::std::string;
  }
  strbasispath_->assign(value);
}
inline void basis::set_strbasispath(const char* value) {
  _set_bit(0);
  if (strbasispath_ == &_default_strbasispath_) {
    strbasispath_ = new ::std::string;
  }
  strbasispath_->assign(value);
}
inline void basis::set_strbasispath(const char* value, size_t size) {
  _set_bit(0);
  if (strbasispath_ == &_default_strbasispath_) {
    strbasispath_ = new ::std::string;
  }
  strbasispath_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* basis::mutable_strbasispath() {
  _set_bit(0);
  if (strbasispath_ == &_default_strbasispath_) {
    strbasispath_ = new ::std::string;
  }
  return strbasispath_;
}

// repeated string vecsignalfiles = 2;
inline int basis::vecsignalfiles_size() const {
  return vecsignalfiles_.size();
}
inline void basis::clear_vecsignalfiles() {
  vecsignalfiles_.Clear();
}
inline const ::std::string& basis::vecsignalfiles(int index) const {
  return vecsignalfiles_.Get(index);
}
inline ::std::string* basis::mutable_vecsignalfiles(int index) {
  return vecsignalfiles_.Mutable(index);
}
inline void basis::set_vecsignalfiles(int index, const ::std::string& value) {
  vecsignalfiles_.Mutable(index)->assign(value);
}
inline void basis::set_vecsignalfiles(int index, const char* value) {
  vecsignalfiles_.Mutable(index)->assign(value);
}
inline void basis::set_vecsignalfiles(int index, const char* value, size_t size) {
  vecsignalfiles_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* basis::add_vecsignalfiles() {
  return vecsignalfiles_.Add();
}
inline void basis::add_vecsignalfiles(const ::std::string& value) {
  vecsignalfiles_.Add()->assign(value);
}
inline void basis::add_vecsignalfiles(const char* value) {
  vecsignalfiles_.Add()->assign(value);
}
inline void basis::add_vecsignalfiles(const char* value, size_t size) {
  vecsignalfiles_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
basis::vecsignalfiles() const {
  return vecsignalfiles_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
basis::mutable_vecsignalfiles() {
  return &vecsignalfiles_;
}

// repeated .sln.signal signals = 3;
inline int basis::signals_size() const {
  return signals_.size();
}
inline void basis::clear_signals() {
  signals_.Clear();
}
inline const ::sln::signal& basis::signals(int index) const {
  return signals_.Get(index);
}
inline ::sln::signal* basis::mutable_signals(int index) {
  return signals_.Mutable(index);
}
inline ::sln::signal* basis::add_signals() {
  return signals_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sln::signal >&
basis::signals() const {
  return signals_;
}
inline ::google::protobuf::RepeatedPtrField< ::sln::signal >*
basis::mutable_signals() {
  return &signals_;
}

// repeated bool broad_sig = 4;
inline int basis::broad_sig_size() const {
  return broad_sig_.size();
}
inline void basis::clear_broad_sig() {
  broad_sig_.Clear();
}
inline bool basis::broad_sig(int index) const {
  return broad_sig_.Get(index);
}
inline void basis::set_broad_sig(int index, bool value) {
  broad_sig_.Set(index, value);
}
inline void basis::add_broad_sig(bool value) {
  broad_sig_.Add(value);
}
inline const ::google::protobuf::RepeatedField< bool >&
basis::broad_sig() const {
  return broad_sig_;
}
inline ::google::protobuf::RepeatedField< bool >*
basis::mutable_broad_sig() {
  return &broad_sig_;
}

// -------------------------------------------------------------------

// options

// optional .sln.options.fidformat format = 1;
inline bool options::has_format() const {
  return _has_bit(0);
}
inline void options::clear_format() {
  format_ = 0;
  _clear_bit(0);
}
inline ::sln::options_fidformat options::format() const {
  return static_cast< ::sln::options_fidformat >(format_);
}
inline void options::set_format(::sln::options_fidformat value) {
  GOOGLE_DCHECK(::sln::options_fidformat_IsValid(value));
  _set_bit(0);
  format_ = value;
}

// optional string strbasispath = 2;
inline bool options::has_strbasispath() const {
  return _has_bit(1);
}
inline void options::clear_strbasispath() {
  if (strbasispath_ != &_default_strbasispath_) {
    strbasispath_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& options::strbasispath() const {
  return *strbasispath_;
}
inline void options::set_strbasispath(const ::std::string& value) {
  _set_bit(1);
  if (strbasispath_ == &_default_strbasispath_) {
    strbasispath_ = new ::std::string;
  }
  strbasispath_->assign(value);
}
inline void options::set_strbasispath(const char* value) {
  _set_bit(1);
  if (strbasispath_ == &_default_strbasispath_) {
    strbasispath_ = new ::std::string;
  }
  strbasispath_->assign(value);
}
inline void options::set_strbasispath(const char* value, size_t size) {
  _set_bit(1);
  if (strbasispath_ == &_default_strbasispath_) {
    strbasispath_ = new ::std::string;
  }
  strbasispath_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* options::mutable_strbasispath() {
  _set_bit(1);
  if (strbasispath_ == &_default_strbasispath_) {
    strbasispath_ = new ::std::string;
  }
  return strbasispath_;
}

// optional bool buseprecompiled = 3;
inline bool options::has_buseprecompiled() const {
  return _has_bit(2);
}
inline void options::clear_buseprecompiled() {
  buseprecompiled_ = false;
  _clear_bit(2);
}
inline bool options::buseprecompiled() const {
  return buseprecompiled_;
}
inline void options::set_buseprecompiled(bool value) {
  _set_bit(2);
  buseprecompiled_ = value;
}

// optional int32 nstart = 4;
inline bool options::has_nstart() const {
  return _has_bit(3);
}
inline void options::clear_nstart() {
  nstart_ = 0;
  _clear_bit(3);
}
inline ::google::protobuf::int32 options::nstart() const {
  return nstart_;
}
inline void options::set_nstart(::google::protobuf::int32 value) {
  _set_bit(3);
  nstart_ = value;
}

// optional int32 nend = 5;
inline bool options::has_nend() const {
  return _has_bit(4);
}
inline void options::clear_nend() {
  nend_ = 0;
  _clear_bit(4);
}
inline ::google::protobuf::int32 options::nend() const {
  return nend_;
}
inline void options::set_nend(::google::protobuf::int32 value) {
  _set_bit(4);
  nend_ = value;
}

// optional double phi0_lower = 6;
inline bool options::has_phi0_lower() const {
  return _has_bit(5);
}
inline void options::clear_phi0_lower() {
  phi0_lower_ = 0;
  _clear_bit(5);
}
inline double options::phi0_lower() const {
  return phi0_lower_;
}
inline void options::set_phi0_lower(double value) {
  _set_bit(5);
  phi0_lower_ = value;
}

// optional double phi0_upper = 7;
inline bool options::has_phi0_upper() const {
  return _has_bit(6);
}
inline void options::clear_phi0_upper() {
  phi0_upper_ = 0;
  _clear_bit(6);
}
inline double options::phi0_upper() const {
  return phi0_upper_;
}
inline void options::set_phi0_upper(double value) {
  _set_bit(6);
  phi0_upper_ = value;
}

// optional double phi0_typ = 8;
inline bool options::has_phi0_typ() const {
  return _has_bit(7);
}
inline void options::clear_phi0_typ() {
  phi0_typ_ = 0;
  _clear_bit(7);
}
inline double options::phi0_typ() const {
  return phi0_typ_;
}
inline void options::set_phi0_typ(double value) {
  _set_bit(7);
  phi0_typ_ = value;
}

// optional double phi1_lower = 9;
inline bool options::has_phi1_lower() const {
  return _has_bit(8);
}
inline void options::clear_phi1_lower() {
  phi1_lower_ = 0;
  _clear_bit(8);
}
inline double options::phi1_lower() const {
  return phi1_lower_;
}
inline void options::set_phi1_lower(double value) {
  _set_bit(8);
  phi1_lower_ = value;
}

// optional double phi1_upper = 10;
inline bool options::has_phi1_upper() const {
  return _has_bit(9);
}
inline void options::clear_phi1_upper() {
  phi1_upper_ = 0;
  _clear_bit(9);
}
inline double options::phi1_upper() const {
  return phi1_upper_;
}
inline void options::set_phi1_upper(double value) {
  _set_bit(9);
  phi1_upper_ = value;
}

// optional double phi1_typ = 11;
inline bool options::has_phi1_typ() const {
  return _has_bit(10);
}
inline void options::clear_phi1_typ() {
  phi1_typ_ = 0;
  _clear_bit(10);
}
inline double options::phi1_typ() const {
  return phi1_typ_;
}
inline void options::set_phi1_typ(double value) {
  _set_bit(10);
  phi1_typ_ = value;
}

// repeated .sln.constraints cons = 12;
inline int options::cons_size() const {
  return cons_.size();
}
inline void options::clear_cons() {
  cons_.Clear();
}
inline const ::sln::constraints& options::cons(int index) const {
  return cons_.Get(index);
}
inline ::sln::constraints* options::mutable_cons(int index) {
  return cons_.Mutable(index);
}
inline ::sln::constraints* options::add_cons() {
  return cons_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sln::constraints >&
options::cons() const {
  return cons_;
}
inline ::google::protobuf::RepeatedPtrField< ::sln::constraints >*
options::mutable_cons() {
  return &cons_;
}

// optional string stroutputxmlpath = 13;
inline bool options::has_stroutputxmlpath() const {
  return _has_bit(12);
}
inline void options::clear_stroutputxmlpath() {
  if (stroutputxmlpath_ != &_default_stroutputxmlpath_) {
    stroutputxmlpath_->clear();
  }
  _clear_bit(12);
}
inline const ::std::string& options::stroutputxmlpath() const {
  return *stroutputxmlpath_;
}
inline void options::set_stroutputxmlpath(const ::std::string& value) {
  _set_bit(12);
  if (stroutputxmlpath_ == &_default_stroutputxmlpath_) {
    stroutputxmlpath_ = new ::std::string;
  }
  stroutputxmlpath_->assign(value);
}
inline void options::set_stroutputxmlpath(const char* value) {
  _set_bit(12);
  if (stroutputxmlpath_ == &_default_stroutputxmlpath_) {
    stroutputxmlpath_ = new ::std::string;
  }
  stroutputxmlpath_->assign(value);
}
inline void options::set_stroutputxmlpath(const char* value, size_t size) {
  _set_bit(12);
  if (stroutputxmlpath_ == &_default_stroutputxmlpath_) {
    stroutputxmlpath_ = new ::std::string;
  }
  stroutputxmlpath_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* options::mutable_stroutputxmlpath() {
  _set_bit(12);
  if (stroutputxmlpath_ == &_default_stroutputxmlpath_) {
    stroutputxmlpath_ = new ::std::string;
  }
  return stroutputxmlpath_;
}

// optional string strfile = 14;
inline bool options::has_strfile() const {
  return _has_bit(13);
}
inline void options::clear_strfile() {
  if (strfile_ != &_default_strfile_) {
    strfile_->clear();
  }
  _clear_bit(13);
}
inline const ::std::string& options::strfile() const {
  return *strfile_;
}
inline void options::set_strfile(const ::std::string& value) {
  _set_bit(13);
  if (strfile_ == &_default_strfile_) {
    strfile_ = new ::std::string;
  }
  strfile_->assign(value);
}
inline void options::set_strfile(const char* value) {
  _set_bit(13);
  if (strfile_ == &_default_strfile_) {
    strfile_ = new ::std::string;
  }
  strfile_->assign(value);
}
inline void options::set_strfile(const char* value, size_t size) {
  _set_bit(13);
  if (strfile_ == &_default_strfile_) {
    strfile_ = new ::std::string;
  }
  strfile_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* options::mutable_strfile() {
  _set_bit(13);
  if (strfile_ == &_default_strfile_) {
    strfile_ = new ::std::string;
  }
  return strfile_;
}

// optional string strfilewater = 15;
inline bool options::has_strfilewater() const {
  return _has_bit(14);
}
inline void options::clear_strfilewater() {
  if (strfilewater_ != &_default_strfilewater_) {
    strfilewater_->clear();
  }
  _clear_bit(14);
}
inline const ::std::string& options::strfilewater() const {
  return *strfilewater_;
}
inline void options::set_strfilewater(const ::std::string& value) {
  _set_bit(14);
  if (strfilewater_ == &_default_strfilewater_) {
    strfilewater_ = new ::std::string;
  }
  strfilewater_->assign(value);
}
inline void options::set_strfilewater(const char* value) {
  _set_bit(14);
  if (strfilewater_ == &_default_strfilewater_) {
    strfilewater_ = new ::std::string;
  }
  strfilewater_->assign(value);
}
inline void options::set_strfilewater(const char* value, size_t size) {
  _set_bit(14);
  if (strfilewater_ == &_default_strfilewater_) {
    strfilewater_ = new ::std::string;
  }
  strfilewater_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* options::mutable_strfilewater() {
  _set_bit(14);
  if (strfilewater_ == &_default_strfilewater_) {
    strfilewater_ = new ::std::string;
  }
  return strfilewater_;
}

// optional string strfileoutimag = 16;
inline bool options::has_strfileoutimag() const {
  return _has_bit(15);
}
inline void options::clear_strfileoutimag() {
  if (strfileoutimag_ != &_default_strfileoutimag_) {
    strfileoutimag_->clear();
  }
  _clear_bit(15);
}
inline const ::std::string& options::strfileoutimag() const {
  return *strfileoutimag_;
}
inline void options::set_strfileoutimag(const ::std::string& value) {
  _set_bit(15);
  if (strfileoutimag_ == &_default_strfileoutimag_) {
    strfileoutimag_ = new ::std::string;
  }
  strfileoutimag_->assign(value);
}
inline void options::set_strfileoutimag(const char* value) {
  _set_bit(15);
  if (strfileoutimag_ == &_default_strfileoutimag_) {
    strfileoutimag_ = new ::std::string;
  }
  strfileoutimag_->assign(value);
}
inline void options::set_strfileoutimag(const char* value, size_t size) {
  _set_bit(15);
  if (strfileoutimag_ == &_default_strfileoutimag_) {
    strfileoutimag_ = new ::std::string;
  }
  strfileoutimag_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* options::mutable_strfileoutimag() {
  _set_bit(15);
  if (strfileoutimag_ == &_default_strfileoutimag_) {
    strfileoutimag_ = new ::std::string;
  }
  return strfileoutimag_;
}

// optional string strfileouttxt = 17;
inline bool options::has_strfileouttxt() const {
  return _has_bit(16);
}
inline void options::clear_strfileouttxt() {
  if (strfileouttxt_ != &_default_strfileouttxt_) {
    strfileouttxt_->clear();
  }
  _clear_bit(16);
}
inline const ::std::string& options::strfileouttxt() const {
  return *strfileouttxt_;
}
inline void options::set_strfileouttxt(const ::std::string& value) {
  _set_bit(16);
  if (strfileouttxt_ == &_default_strfileouttxt_) {
    strfileouttxt_ = new ::std::string;
  }
  strfileouttxt_->assign(value);
}
inline void options::set_strfileouttxt(const char* value) {
  _set_bit(16);
  if (strfileouttxt_ == &_default_strfileouttxt_) {
    strfileouttxt_ = new ::std::string;
  }
  strfileouttxt_->assign(value);
}
inline void options::set_strfileouttxt(const char* value, size_t size) {
  _set_bit(16);
  if (strfileouttxt_ == &_default_strfileouttxt_) {
    strfileouttxt_ = new ::std::string;
  }
  strfileouttxt_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* options::mutable_strfileouttxt() {
  _set_bit(16);
  if (strfileouttxt_ == &_default_strfileouttxt_) {
    strfileouttxt_ = new ::std::string;
  }
  return strfileouttxt_;
}

// optional string strfileoutcsv = 18;
inline bool options::has_strfileoutcsv() const {
  return _has_bit(17);
}
inline void options::clear_strfileoutcsv() {
  if (strfileoutcsv_ != &_default_strfileoutcsv_) {
    strfileoutcsv_->clear();
  }
  _clear_bit(17);
}
inline const ::std::string& options::strfileoutcsv() const {
  return *strfileoutcsv_;
}
inline void options::set_strfileoutcsv(const ::std::string& value) {
  _set_bit(17);
  if (strfileoutcsv_ == &_default_strfileoutcsv_) {
    strfileoutcsv_ = new ::std::string;
  }
  strfileoutcsv_->assign(value);
}
inline void options::set_strfileoutcsv(const char* value) {
  _set_bit(17);
  if (strfileoutcsv_ == &_default_strfileoutcsv_) {
    strfileoutcsv_ = new ::std::string;
  }
  strfileoutcsv_->assign(value);
}
inline void options::set_strfileoutcsv(const char* value, size_t size) {
  _set_bit(17);
  if (strfileoutcsv_ == &_default_strfileoutcsv_) {
    strfileoutcsv_ = new ::std::string;
  }
  strfileoutcsv_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* options::mutable_strfileoutcsv() {
  _set_bit(17);
  if (strfileoutcsv_ == &_default_strfileoutcsv_) {
    strfileoutcsv_ = new ::std::string;
  }
  return strfileoutcsv_;
}

// optional int32 conv_window_width = 19;
inline bool options::has_conv_window_width() const {
  return _has_bit(18);
}
inline void options::clear_conv_window_width() {
  conv_window_width_ = 0;
  _clear_bit(18);
}
inline ::google::protobuf::int32 options::conv_window_width() const {
  return conv_window_width_;
}
inline void options::set_conv_window_width(::google::protobuf::int32 value) {
  _set_bit(18);
  conv_window_width_ = value;
}

// optional int32 water_window = 20;
inline bool options::has_water_window() const {
  return _has_bit(19);
}
inline void options::clear_water_window() {
  water_window_ = 0;
  _clear_bit(19);
}
inline ::google::protobuf::int32 options::water_window() const {
  return water_window_;
}
inline void options::set_water_window(::google::protobuf::int32 value) {
  _set_bit(19);
  water_window_ = value;
}

// optional bool bautophase = 21;
inline bool options::has_bautophase() const {
  return _has_bit(20);
}
inline void options::clear_bautophase() {
  bautophase_ = false;
  _clear_bit(20);
}
inline bool options::bautophase() const {
  return bautophase_;
}
inline void options::set_bautophase(bool value) {
  _set_bit(20);
  bautophase_ = value;
}

// optional bool bautoref = 22;
inline bool options::has_bautoref() const {
  return _has_bit(21);
}
inline void options::clear_bautoref() {
  bautoref_ = false;
  _clear_bit(21);
}
inline bool options::bautoref() const {
  return bautoref_;
}
inline void options::set_bautoref(bool value) {
  _set_bit(21);
  bautoref_ = value;
}

// optional bool bShowPreprocessed = 23;
inline bool options::has_bshowpreprocessed() const {
  return _has_bit(22);
}
inline void options::clear_bshowpreprocessed() {
  bshowpreprocessed_ = false;
  _clear_bit(22);
}
inline bool options::bshowpreprocessed() const {
  return bshowpreprocessed_;
}
inline void options::set_bshowpreprocessed(bool value) {
  _set_bit(22);
  bshowpreprocessed_ = value;
}

// optional double ref = 24;
inline bool options::has_ref() const {
  return _has_bit(23);
}
inline void options::clear_ref() {
  ref_ = 0;
  _clear_bit(23);
}
inline double options::ref() const {
  return ref_;
}
inline void options::set_ref(double value) {
  _set_bit(23);
  ref_ = value;
}

// optional double ref_spec = 25;
inline bool options::has_ref_spec() const {
  return _has_bit(24);
}
inline void options::clear_ref_spec() {
  ref_spec_ = 0;
  _clear_bit(24);
}
inline double options::ref_spec() const {
  return ref_spec_;
}
inline void options::set_ref_spec(double value) {
  _set_bit(24);
  ref_spec_ = value;
}

// repeated .sln.coord fit_list = 26;
inline int options::fit_list_size() const {
  return fit_list_.size();
}
inline void options::clear_fit_list() {
  fit_list_.Clear();
}
inline const ::sln::coord& options::fit_list(int index) const {
  return fit_list_.Get(index);
}
inline ::sln::coord* options::mutable_fit_list(int index) {
  return fit_list_.Mutable(index);
}
inline ::sln::coord* options::add_fit_list() {
  return fit_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sln::coord >&
options::fit_list() const {
  return fit_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::sln::coord >*
options::mutable_fit_list() {
  return &fit_list_;
}

// -------------------------------------------------------------------

// constraints

// optional double minalpha = 1;
inline bool constraints::has_minalpha() const {
  return _has_bit(0);
}
inline void constraints::clear_minalpha() {
  minalpha_ = 0;
  _clear_bit(0);
}
inline double constraints::minalpha() const {
  return minalpha_;
}
inline void constraints::set_minalpha(double value) {
  _set_bit(0);
  minalpha_ = value;
}

// optional double maxalpha = 2;
inline bool constraints::has_maxalpha() const {
  return _has_bit(1);
}
inline void constraints::clear_maxalpha() {
  maxalpha_ = 0;
  _clear_bit(1);
}
inline double constraints::maxalpha() const {
  return maxalpha_;
}
inline void constraints::set_maxalpha(double value) {
  _set_bit(1);
  maxalpha_ = value;
}

// optional double typalpha = 3;
inline bool constraints::has_typalpha() const {
  return _has_bit(2);
}
inline void constraints::clear_typalpha() {
  typalpha_ = 0;
  _clear_bit(2);
}
inline double constraints::typalpha() const {
  return typalpha_;
}
inline void constraints::set_typalpha(double value) {
  _set_bit(2);
  typalpha_ = value;
}

// optional double minbeta = 4;
inline bool constraints::has_minbeta() const {
  return _has_bit(3);
}
inline void constraints::clear_minbeta() {
  minbeta_ = 0;
  _clear_bit(3);
}
inline double constraints::minbeta() const {
  return minbeta_;
}
inline void constraints::set_minbeta(double value) {
  _set_bit(3);
  minbeta_ = value;
}

// optional double maxbeta = 5;
inline bool constraints::has_maxbeta() const {
  return _has_bit(4);
}
inline void constraints::clear_maxbeta() {
  maxbeta_ = 0;
  _clear_bit(4);
}
inline double constraints::maxbeta() const {
  return maxbeta_;
}
inline void constraints::set_maxbeta(double value) {
  _set_bit(4);
  maxbeta_ = value;
}

// optional double typbeta = 6;
inline bool constraints::has_typbeta() const {
  return _has_bit(5);
}
inline void constraints::clear_typbeta() {
  typbeta_ = 0;
  _clear_bit(5);
}
inline double constraints::typbeta() const {
  return typbeta_;
}
inline void constraints::set_typbeta(double value) {
  _set_bit(5);
  typbeta_ = value;
}

// optional double minshifthz = 7;
inline bool constraints::has_minshifthz() const {
  return _has_bit(6);
}
inline void constraints::clear_minshifthz() {
  minshifthz_ = 0;
  _clear_bit(6);
}
inline double constraints::minshifthz() const {
  return minshifthz_;
}
inline void constraints::set_minshifthz(double value) {
  _set_bit(6);
  minshifthz_ = value;
}

// optional double maxshifthz = 8;
inline bool constraints::has_maxshifthz() const {
  return _has_bit(7);
}
inline void constraints::clear_maxshifthz() {
  maxshifthz_ = 0;
  _clear_bit(7);
}
inline double constraints::maxshifthz() const {
  return maxshifthz_;
}
inline void constraints::set_maxshifthz(double value) {
  _set_bit(7);
  maxshifthz_ = value;
}

// optional double typshifthz = 9;
inline bool constraints::has_typshifthz() const {
  return _has_bit(8);
}
inline void constraints::clear_typshifthz() {
  typshifthz_ = 0;
  _clear_bit(8);
}
inline double constraints::typshifthz() const {
  return typshifthz_;
}
inline void constraints::set_typshifthz(double value) {
  _set_bit(8);
  typshifthz_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace sln

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sln::options_fidformat>() {
  return ::sln::options_fidformat_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_tarquin_2eproto__INCLUDED
